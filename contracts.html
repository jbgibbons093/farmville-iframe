<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hughberry Farms - Contracts Board</title>
  <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Nunito:wght@600;700;800&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Nunito', sans-serif; background: transparent; display: flex; justify-content: center; }
    .container { width: 100%; max-width: 800px; max-height: 90vh; background: linear-gradient(145deg, #1a2f1f 0%, #0d1a10 100%); border: 4px solid #2ecc71; border-radius: 20px; box-shadow: 0 0 30px rgba(46, 204, 113, 0.3); display: flex; flex-direction: column; overflow: hidden; }

    .header { background: linear-gradient(180deg, #27ae60 0%, #1e8449 100%); padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; }
    .title { font-family: 'Luckiest Guy', cursive; font-size: 22px; color: #fff; text-shadow: 2px 2px 0 #145a32; letter-spacing: 2px; }
    .header-stats { display: flex; gap: 10px; align-items: center; }
    .stat-box { display: flex; align-items: center; gap: 6px; background: rgba(0,0,0,0.3); padding: 6px 12px; border-radius: 8px; }
    .stat-icon { font-size: 16px; }
    .stat-value { font-size: 14px; font-weight: 800; color: #FFD700; }
    .close-btn { background: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.3); color: #fff; width: 32px; height: 32px; border-radius: 8px; font-size: 18px; cursor: pointer; transition: all 0.2s; }
    .close-btn:hover { background: #c0392b; border-color: #e74c3c; }

    .content { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 15px; }

    /* Available Contracts Section */
    .section-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: rgba(46, 204, 113, 0.2); border: 2px solid #27ae60; border-radius: 8px; }
    .section-title { font-size: 14px; font-weight: 800; color: #2ecc71; text-transform: uppercase; letter-spacing: 1px; }
    .refresh-timer { display: flex; align-items: center; gap: 6px; font-size: 13px; color: #f39c12; font-weight: 700; }

    .available-contracts { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; min-height: 100px; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; }

    .contract-card { width: 110px; background: linear-gradient(145deg, #2d4a3a 0%, #1a2f22 100%); border: 2px solid #3d6b4f; border-radius: 10px; padding: 10px; cursor: grab; transition: all 0.2s; user-select: none; }
    .contract-card:hover { border-color: #2ecc71; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3); }
    .contract-card.dragging { opacity: 0.5; cursor: grabbing; }
    .contract-card .items { display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; margin-bottom: 8px; min-height: 44px; }
    .contract-card .item { display: flex; align-items: center; gap: 2px; background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; font-size: 11px; }
    .contract-card .item-icon { font-size: 14px; }
    .contract-card .item-qty { color: #fff; font-weight: 700; }
    .contract-card .rewards { display: flex; justify-content: center; gap: 8px; font-size: 11px; font-weight: 700; }
    .contract-card .reward-gold { color: #FFD700; }
    .contract-card .reward-xp { color: #9b59b6; }

    /* Your Slots Section */
    .slots-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 10px; }

    .slot { background: linear-gradient(145deg, #1e3326 0%, #0f1a12 100%); border: 2px dashed #3d6b4f; border-radius: 10px; padding: 12px; min-height: 80px; transition: all 0.2s; }
    .slot.drag-over { border-color: #2ecc71; border-style: solid; background: rgba(46, 204, 113, 0.1); }
    .slot.locked { opacity: 0.5; border-style: solid; }
    .slot.has-contract { border-style: solid; border-color: #27ae60; }
    .slot.active { border-color: #f39c12; }
    .slot.cooldown { border-color: #555; }

    .slot-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .slot-num { font-size: 12px; color: #888; font-weight: 700; }
    .slot-status { font-size: 10px; padding: 3px 8px; border-radius: 4px; font-weight: 700; text-transform: uppercase; }
    .status-empty { background: #333; color: #888; }
    .status-pending { background: #2980b9; color: #fff; }
    .status-active { background: #f39c12; color: #000; }
    .status-cooldown { background: #555; color: #aaa; }
    .status-locked { background: #333; color: #666; }

    .slot-content { display: flex; flex-direction: column; align-items: center; gap: 8px; }
    .slot-empty-text { font-size: 12px; color: #666; text-align: center; }
    .slot-locked-text { font-size: 12px; color: #888; }
    .slot-locked-req { font-size: 11px; color: #f39c12; }

    .slot-contract { width: 100%; }
    .slot-contract .items { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; margin-bottom: 10px; }
    .slot-contract .item { display: flex; align-items: center; gap: 4px; background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 6px; }
    .slot-contract .item-icon { font-size: 16px; }
    .slot-contract .item-qty { font-size: 12px; font-weight: 700; }
    .slot-contract .item-qty.has-enough { color: #2ecc71; }
    .slot-contract .item-qty.not-enough { color: #e74c3c; }

    .slot-contract .rewards { display: flex; justify-content: center; gap: 12px; margin-bottom: 10px; font-size: 13px; font-weight: 700; }
    .slot-contract .reward-gold { color: #FFD700; }
    .slot-contract .reward-xp { color: #9b59b6; }

    .slot-timer { font-size: 18px; font-weight: 800; color: #f39c12; text-align: center; margin-bottom: 8px; }
    .slot-cooldown-timer { font-size: 14px; color: #888; text-align: center; }

    .slot-buttons { display: flex; gap: 8px; justify-content: center; }
    .btn { padding: 8px 16px; border-radius: 6px; font-size: 12px; font-weight: 700; cursor: pointer; transition: all 0.2s; border: 2px solid; }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
    .btn-accept { background: linear-gradient(180deg, #27ae60 0%, #1e8449 100%); border-color: #2ecc71; color: #fff; }
    .btn-accept:hover:not(:disabled) { transform: scale(1.02); box-shadow: 0 0 10px rgba(46, 204, 113, 0.5); }
    .btn-remove { background: linear-gradient(180deg, #7f8c8d 0%, #5d6d6d 100%); border-color: #95a5a6; color: #fff; }
    .btn-remove:hover:not(:disabled) { background: linear-gradient(180deg, #c0392b 0%, #96281b 100%); border-color: #e74c3c; }
    .btn-fill { background: linear-gradient(180deg, #f39c12 0%, #d68910 100%); border-color: #f1c40f; color: #000; }
    .btn-fill:hover:not(:disabled) { transform: scale(1.02); box-shadow: 0 0 10px rgba(241, 196, 15, 0.5); }

    .notification { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; border-radius: 10px; font-weight: 700; z-index: 1000; animation: slideIn 0.3s ease; }
    .notification.success { background: #27ae60; color: #fff; }
    .notification.error { background: #e74c3c; color: #fff; }
    @keyframes slideIn { from { opacity: 0; top: 0; } to { opacity: 1; top: 20px; } }

    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
    ::-webkit-scrollbar-thumb { background: #27ae60; border-radius: 4px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title">CONTRACTS</div>
      <div class="header-stats">
        <div class="stat-box">
          <span class="stat-icon">&#x1F4B0;</span>
          <span class="stat-value" id="gold-display">0</span>
        </div>
        <div class="stat-box">
          <span class="stat-icon">&#x2B50;</span>
          <span class="stat-value">Lv.<span id="level-display">0</span></span>
        </div>
        <button class="close-btn" onclick="closeIframe()">&#x2715;</button>
      </div>
    </div>

    <div class="content">
      <!-- Available Contracts -->
      <div class="section-header">
        <div class="section-title">Available Contracts</div>
        <div class="refresh-timer">
          <span>&#x1F504;</span>
          <span>Refreshes in <span id="refresh-timer">3:00</span></span>
        </div>
      </div>
      <div class="available-contracts" id="available-contracts"></div>

      <!-- Your Slots -->
      <div class="section-header">
        <div class="section-title">Your Contract Slots</div>
        <div style="font-size: 12px; color: #aaa;"><span id="slots-unlocked">1</span> / 10 unlocked</div>
      </div>
      <div class="slots-grid" id="slots-grid"></div>
    </div>
  </div>

  <script src="https://portals-labs.github.io/portals-sdk/portals-sdk.js"></script>
  <script>
    // ============================================
    // HUGHBERRY FARMS - CONTRACTS BOARD v2
    // ============================================

    const REFRESH_MS = 3 * 60 * 1000; // 3 minutes
    const FULFILL_MS = 10 * 60 * 1000; // 10 minutes to fulfill
    const COOLDOWN_MS = 10 * 60 * 1000; // 10 minutes cooldown after

    // Items with their properties
    const ITEMS = {
      wheat: { name: 'Wheat', icon: '&#x1F33E;', value: 5, unlockLevel: 0, varKey: 'crop_wheat', deductTask: 'Deduct_Crop_Wheat_1' },
      carrot: { name: 'Carrot', icon: '&#x1F955;', value: 10, unlockLevel: 3, varKey: 'crop_carrot', deductTask: 'Deduct_Crop_Carrot_1' },
      corn: { name: 'Corn', icon: '&#x1F33D;', value: 8, unlockLevel: 7, varKey: 'crop_corn', deductTask: 'Deduct_Crop_Corn_1' },
      potato: { name: 'Potato', icon: '&#x1F954;', value: 12, unlockLevel: 10, varKey: 'crop_potato', deductTask: 'Deduct_Crop_Potato_1' },
      tomato: { name: 'Tomato', icon: '&#x1F345;', value: 15, unlockLevel: 16, varKey: 'crop_tomato', deductTask: 'Deduct_Crop_Tomato_1' },
      pumpkin: { name: 'Pumpkin', icon: '&#x1F383;', value: 30, unlockLevel: 23, varKey: 'crop_pumpkin', deductTask: 'Deduct_Crop_Pumpkin_1' },
      milk: { name: 'Milk', icon: '&#x1F95B;', value: 12, unlockLevel: 2, varKey: 'milk', deductTask: 'Deduct_Milk_1' },
      egg: { name: 'Egg', icon: '&#x1F95A;', value: 8, unlockLevel: 6, varKey: 'egg', deductTask: 'Deduct_Egg_1' },
      wool: { name: 'Wool', icon: '&#x1F9F6;', value: 15, unlockLevel: 13, varKey: 'wool', deductTask: 'Deduct_Wool_1' },
      goat_meat: { name: 'Goat Meat', icon: '&#x1F356;', value: 20, unlockLevel: 18, varKey: 'goat_meat', deductTask: 'Deduct_Goat_Meat_1' },
      honey: { name: 'Honey', icon: '&#x1F36F;', value: 25, unlockLevel: 21, varKey: 'honey', deductTask: 'Deduct_Honey_1' },
      truffle: { name: 'Truffle', icon: '&#x1F344;', value: 50, unlockLevel: 26, varKey: 'truffle', deductTask: 'Deduct_Truffle_1' },
      flour: { name: 'Flour', icon: '&#x1F35E;', value: 10, unlockLevel: 4, varKey: 'flour', deductTask: 'Deduct_Flour_1' },
      butter: { name: 'Butter', icon: '&#x1F9C8;', value: 30, unlockLevel: 8, varKey: 'butter', deductTask: 'Deduct_Butter_1' },
      cheese: { name: 'Cheese', icon: '&#x1F9C0;', value: 45, unlockLevel: 9, varKey: 'cheese', deductTask: 'Deduct_Cheese_1' },
      bread: { name: 'Bread', icon: '&#x1F956;', value: 35, unlockLevel: 11, varKey: 'bread', deductTask: 'Deduct_Bread_1' },
      blanket: { name: 'Blanket', icon: '&#x1F9E3;', value: 60, unlockLevel: 14, varKey: 'blanket', deductTask: 'Deduct_Blanket_1' },
      stew: { name: 'Stew', icon: '&#x1F372;', value: 50, unlockLevel: 15, varKey: 'stew', deductTask: 'Deduct_Stew_1' },
      ragout: { name: 'Ragout', icon: '&#x1F356;', value: 75, unlockLevel: 19, varKey: 'ragout', deductTask: 'Deduct_Ragout_1' },
      mead: { name: 'Mead', icon: '&#x1F37A;', value: 100, unlockLevel: 22, varKey: 'mead', deductTask: 'Deduct_Mead_1' },
      pie: { name: 'Pie', icon: '&#x1F967;', value: 100, unlockLevel: 24, varKey: 'pie', deductTask: 'Deduct_Pie_1' },
      meat_pie: { name: 'Meat Pie', icon: '&#x1F969;', value: 90, unlockLevel: 27, varKey: 'meat_pie', deductTask: 'Deduct_Meat_Pie_1' },
      cake: { name: 'Cake', icon: '&#x1F370;', value: 150, unlockLevel: 28, varKey: 'cake', deductTask: 'Deduct_Cake_1' }
    };

    const TIER_CONFIG = {
      1: { minLevel: 0, maxLevel: 9, goldMult: 1.0, xpMult: 1.0 },
      2: { minLevel: 10, maxLevel: 19, goldMult: 1.5, xpMult: 1.5 },
      3: { minLevel: 20, maxLevel: 29, goldMult: 2.0, xpMult: 2.0 },
      4: { minLevel: 30, maxLevel: 39, goldMult: 2.5, xpMult: 2.5 },
      5: { minLevel: 40, maxLevel: 50, goldMult: 3.0, xpMult: 3.0 }
    };

    let gameState = {
      gold: 0,
      level: 0,
      inventory: {},
      talents: { contractor1: 0, contractor2: 0, contractor3: 0 }
    };

    // Available contracts pool
    let availableContracts = [];
    let refreshEndTime = null;

    // Player's 10 slots
    let slots = [];
    for (let i = 0; i < 10; i++) {
      slots.push({
        id: i + 1,
        state: 'empty', // empty, pending, active, cooldown
        contract: null,
        endTime: null // For active (fulfill deadline) or cooldown
      });
    }

    let actionPending = false;
    let notificationTimeout = null;
    let draggedContractIndex = null;

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    function getTier(level) {
      if (level >= 40) return 5;
      if (level >= 30) return 4;
      if (level >= 20) return 3;
      if (level >= 10) return 2;
      return 1;
    }

    function getUnlockedSlots() {
      const t = gameState.talents;
      return 1 + t.contractor1 + t.contractor2 + t.contractor3;
    }

    function getAvailableContractCount() {
      return getUnlockedSlots() + 5;
    }

    function getAvailableItems(level) {
      return Object.entries(ITEMS)
        .filter(([key, item]) => item.unlockLevel <= level)
        .map(([key, item]) => ({ key, ...item }));
    }

    function generateContract(level) {
      const tier = getTier(level);
      const tierConfig = TIER_CONFIG[tier];
      const availableItems = getAvailableItems(level);
      if (availableItems.length === 0) return null;

      const numItems = Math.random() < 0.7 ? 1 : 2;
      const selectedItems = [];
      const usedIndices = new Set();

      for (let i = 0; i < numItems && i < availableItems.length; i++) {
        let idx;
        do {
          idx = Math.floor(Math.random() * availableItems.length);
        } while (usedIndices.has(idx) && usedIndices.size < availableItems.length);
        usedIndices.add(idx);

        const item = availableItems[idx];
        const maxQty = Math.max(2, Math.floor(100 / item.value));
        const qty = Math.max(1, Math.floor(Math.random() * maxQty) + 1);
        selectedItems.push({ ...item, qty });
      }

      const baseCost = selectedItems.reduce((sum, item) => sum + item.value * item.qty, 0);
      const profitMult = 1.25 + (Math.random() * 0.5);
      const rawGold = baseCost * profitMult * tierConfig.goldMult;
      const goldReward = Math.max(25, Math.round(rawGold / 25) * 25);
      const xpReward = Math.floor(goldReward * 0.3 * tierConfig.xpMult);

      return { items: selectedItems, goldReward, xpReward, tier };
    }

    function refreshAvailableContracts() {
      const count = getAvailableContractCount();
      availableContracts = [];
      for (let i = 0; i < count; i++) {
        const contract = generateContract(gameState.level);
        if (contract) availableContracts.push(contract);
      }
      refreshEndTime = Date.now() + REFRESH_MS;
      render();
    }

    function formatTime(ms) {
      if (ms <= 0) return '0:00';
      const totalSec = Math.ceil(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return min + ':' + (sec < 10 ? '0' : '') + sec;
    }

    // ============================================
    // PORTALS COMMUNICATION
    // ============================================

    function triggerTask(taskName) {
      if (typeof PortalsSdk !== 'undefined' && PortalsSdk.sendMessageToUnity) {
        PortalsSdk.sendMessageToUnity(JSON.stringify({ TaskName: taskName, TaskTargetState: 'SetNotActiveToActive' }));
        console.log('[Contracts] Triggered task:', taskName);
      } else {
        console.log('[Contracts] SDK not ready, cannot trigger:', taskName);
      }
    }

    function closeIframe() {
      playSound();
      if (typeof PortalsSdk !== 'undefined' && PortalsSdk.closeIframe) {
        PortalsSdk.closeIframe();
      }
    }

    // ============================================
    // SYNC INVENTORY PARSER
    // ============================================

    const SYNC_MAP = {
      'Gold': 'gold', 'XP': 'xp', 'Level': 'level',
      'Crop_Wheat': 'crop_wheat', 'Crop_Carrot': 'crop_carrot', 'Crop_Corn': 'crop_corn',
      'Crop_Potato': 'crop_potato', 'Crop_Tomato': 'crop_tomato', 'Crop_Pumpkin': 'crop_pumpkin',
      'Milk': 'milk', 'Egg': 'egg', 'Wool': 'wool', 'Goat_Meat': 'goat_meat',
      'Truffle': 'truffle', 'Honey': 'honey',
      'Flour': 'flour', 'Bread': 'bread', 'Cheese': 'cheese', 'Stew': 'stew',
      'Ragout': 'ragout', 'Pie': 'pie', 'Meat_Pie': 'meat_pie', 'Blanket': 'blanket',
      'Butter': 'butter', 'Cake': 'cake', 'Mead': 'mead',
      'T_Contractor1': 't_contractor1', 'T_Contractor2': 't_contractor2', 'T_Contractor3': 't_contractor3'
    };

    const SKIP_PREFIXES = ['T_PlotRow', 'T_Green', 'T_Eager', 'T_Bountiful', 'T_Rapid', 'T_Crop',
      'T_Cow', 'T_Chicken', 'T_Quick', 'T_Sheep', 'T_Goat', 'T_Apiary', 'T_Husbandry', 'T_Pig', 'T_Animal',
      'T_Keen', 'T_Farm', 'T_Stock', 'T_Artisan', 'T_Seasoned', 'T_Bonus', 'T_Prodigy',
      'Has_Milk', 'Has_Basket', 'Has_Bee', 'Has_Shearing', 'Has_Butcher', 'Has_Truffle',
      'Has_Recipe', 'Has_Starter', 'Seeds_', 'Unspent_', 'Rebirth_', 'playerName', 'Contract_'];

    function shouldSkip(key) {
      return SKIP_PREFIXES.some(p => key.indexOf(p) === 0);
    }

    function parseSyncInventory(msg) {
      const data = {};
      const parts = msg.split('_');
      let i = 0;
      if (parts[0] === 'Sync' && parts[1] === 'Inventory') i = 2;

      while (i < parts.length) {
        let matched = false;

        if (!matched && i + 3 < parts.length) {
          const k3 = parts[i] + '_' + parts[i+1] + '_' + parts[i+2];
          if (SYNC_MAP[k3] !== undefined) {
            const val = parseInt(parts[i+3]);
            data[SYNC_MAP[k3]] = isNaN(val) ? 0 : val;
            i += 4; matched = true;
          } else if (shouldSkip(k3)) {
            i += 4; matched = true;
          }
        }

        if (!matched && i + 2 < parts.length) {
          const k2 = parts[i] + '_' + parts[i+1];
          if (SYNC_MAP[k2] !== undefined) {
            const val = parseInt(parts[i+2]);
            data[SYNC_MAP[k2]] = isNaN(val) ? 0 : val;
            i += 3; matched = true;
          } else if (shouldSkip(k2)) {
            i += 3; matched = true;
          }
        }

        if (!matched && i + 1 < parts.length) {
          if (SYNC_MAP[parts[i]] !== undefined) {
            const val = parseInt(parts[i+1]);
            data[SYNC_MAP[parts[i]]] = isNaN(val) ? 0 : val;
            i += 2; matched = true;
          } else if (shouldSkip(parts[i])) {
            i += 2; matched = true;
          }
        }

        if (!matched) i++;
      }
      return data;
    }

    function handlePortalsMessage(msg) {
      if (typeof msg !== 'string') return;
      if (msg.indexOf('Sync_Inventory') !== 0) return;

      console.log('[Contracts] Received Sync_Inventory');
      const data = parseSyncInventory(msg);
      console.log('[Contracts] Parsed data:', data);

      gameState.gold = data.gold !== undefined ? data.gold : 0;
      gameState.level = data.level !== undefined ? data.level : 0;

      Object.keys(ITEMS).forEach(key => {
        const varKey = ITEMS[key].varKey;
        gameState.inventory[key] = data[varKey] !== undefined ? data[varKey] : 0;
      });

      gameState.talents.contractor1 = data.t_contractor1 !== undefined ? data.t_contractor1 : 0;
      gameState.talents.contractor2 = data.t_contractor2 !== undefined ? data.t_contractor2 : 0;
      gameState.talents.contractor3 = data.t_contractor3 !== undefined ? data.t_contractor3 : 0;

      console.log('[Contracts] Inventory:', gameState.inventory);

      // Initialize available contracts if not done
      if (availableContracts.length === 0) {
        refreshAvailableContracts();
      }

      actionPending = false;
      render();
    }

    // ============================================
    // DRAG AND DROP
    // ============================================

    function onDragStart(e, index) {
      draggedContractIndex = index;
      e.target.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function onDragEnd(e) {
      draggedContractIndex = null;
      e.target.classList.remove('dragging');
    }

    function onSlotDragOver(e, slotIndex) {
      e.preventDefault();
      const slot = slots[slotIndex];
      if (slot.state === 'empty' && slotIndex < getUnlockedSlots()) {
        e.currentTarget.classList.add('drag-over');
      }
    }

    function onSlotDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function onSlotDrop(e, slotIndex) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');

      const slot = slots[slotIndex];
      if (slot.state !== 'empty' || slotIndex >= getUnlockedSlots()) return;
      if (draggedContractIndex === null) return;

      const contract = availableContracts[draggedContractIndex];
      if (!contract) return;

      // Move contract to slot as pending
      slot.state = 'pending';
      slot.contract = contract;

      // Remove from available
      availableContracts.splice(draggedContractIndex, 1);
      draggedContractIndex = null;

      playSound();
      render();
    }

    // ============================================
    // SLOT ACTIONS
    // ============================================

    function acceptContract(slotIndex) {
      const slot = slots[slotIndex];
      if (slot.state !== 'pending') return;

      slot.state = 'active';
      slot.endTime = Date.now() + FULFILL_MS;

      playSound();
      render();
    }

    function removeContract(slotIndex) {
      const slot = slots[slotIndex];
      if (slot.state !== 'pending') return;

      // Return contract to available pool
      if (slot.contract) {
        availableContracts.push(slot.contract);
      }

      slot.state = 'empty';
      slot.contract = null;
      slot.endTime = null;

      playSound();
      render();
    }

    function canFillContract(slot) {
      if (!slot.contract || slot.state !== 'active' || actionPending) return false;
      return slot.contract.items.every(item => {
        const owned = gameState.inventory[item.key] || 0;
        return owned >= item.qty;
      });
    }

    function fillContract(slotIndex) {
      const slot = slots[slotIndex];
      if (!canFillContract(slot)) return;

      actionPending = true;
      playSound();

      const contract = slot.contract;

      // Optimistically deduct items
      contract.items.forEach(item => {
        gameState.inventory[item.key] = (gameState.inventory[item.key] || 0) - item.qty;
      });

      // Build task list
      const deductTasks = [];
      contract.items.forEach(item => {
        for (let i = 0; i < item.qty; i++) {
          deductTasks.push(item.deductTask);
        }
      });

      const goldTasks = getRewardTasks(contract.goldReward, 'Add_Gold_', [1000, 500, 250, 100, 50, 25]);
      const xpTasks = getRewardTasks(contract.xpReward, 'Add_XP_', [500, 250, 100, 50, 40, 35, 30, 25, 20, 15, 10, 8, 6, 5, 4, 3, 2, 1]);

      let delay = 0;
      const STAGGER = 200;

      deductTasks.forEach(task => { setTimeout(() => triggerTask(task), delay); delay += STAGGER; });
      goldTasks.forEach(task => { setTimeout(() => triggerTask(task), delay); delay += STAGGER; });
      xpTasks.forEach(task => { setTimeout(() => triggerTask(task), delay); delay += STAGGER; });

      // Set slot to cooldown
      slot.state = 'cooldown';
      slot.contract = null;
      slot.endTime = Date.now() + COOLDOWN_MS;

      notify('Contract fulfilled! +' + contract.goldReward + 'g +' + contract.xpReward + ' XP', 'success');
      render();

      setTimeout(() => { actionPending = false; render(); }, 5000);
    }

    function getRewardTasks(amount, prefix, denominations) {
      const tasks = [];
      let remaining = amount;
      for (const denom of denominations) {
        while (remaining >= denom) {
          tasks.push(prefix + denom);
          remaining -= denom;
        }
      }
      return tasks;
    }

    // ============================================
    // GAME LOOP
    // ============================================

    function gameLoop() {
      const now = Date.now();

      // Check refresh timer
      if (refreshEndTime && now >= refreshEndTime) {
        refreshAvailableContracts();
      }

      // Check slot timers
      slots.forEach((slot, i) => {
        if (slot.endTime && now >= slot.endTime) {
          if (slot.state === 'active') {
            // Contract expired - failed
            slot.state = 'cooldown';
            slot.contract = null;
            slot.endTime = now + COOLDOWN_MS;
            notify('Contract expired!', 'error');
          } else if (slot.state === 'cooldown') {
            // Cooldown finished
            slot.state = 'empty';
            slot.contract = null;
            slot.endTime = null;
          }
        }
      });

      updateTimers();
    }

    function updateTimers() {
      const now = Date.now();

      // Refresh timer
      if (refreshEndTime) {
        document.getElementById('refresh-timer').textContent = formatTime(refreshEndTime - now);
      }

      // Slot timers
      slots.forEach((slot, i) => {
        const timerEl = document.getElementById('slot-timer-' + i);
        if (timerEl && slot.endTime) {
          timerEl.textContent = formatTime(slot.endTime - now);
        }
      });
    }

    // ============================================
    // RENDER
    // ============================================

    function render() {
      document.getElementById('gold-display').textContent = gameState.gold.toLocaleString();
      document.getElementById('level-display').textContent = gameState.level;
      document.getElementById('slots-unlocked').textContent = getUnlockedSlots();

      renderAvailableContracts();
      renderSlots();
    }

    function renderAvailableContracts() {
      const container = document.getElementById('available-contracts');
      let html = '';

      availableContracts.forEach((contract, index) => {
        let itemsHtml = '';
        contract.items.forEach(item => {
          itemsHtml += '<div class="item"><span class="item-icon">' + item.icon + '</span><span class="item-qty">x' + item.qty + '</span></div>';
        });

        html += '<div class="contract-card" draggable="true" ondragstart="onDragStart(event, ' + index + ')" ondragend="onDragEnd(event)">' +
          '<div class="items">' + itemsHtml + '</div>' +
          '<div class="rewards">' +
            '<span class="reward-gold">' + contract.goldReward + 'g</span>' +
            '<span class="reward-xp">' + contract.xpReward + 'xp</span>' +
          '</div>' +
        '</div>';
      });

      if (availableContracts.length === 0) {
        html = '<div style="color:#888;font-size:13px;">No contracts available</div>';
      }

      container.innerHTML = html;
    }

    function renderSlots() {
      const container = document.getElementById('slots-grid');
      const unlockedCount = getUnlockedSlots();
      let html = '';

      slots.forEach((slot, i) => {
        const isUnlocked = i < unlockedCount;
        const slotClass = 'slot' +
          (slot.state === 'pending' || slot.state === 'active' ? ' has-contract' : '') +
          (slot.state === 'active' ? ' active' : '') +
          (slot.state === 'cooldown' ? ' cooldown' : '') +
          (!isUnlocked ? ' locked' : '');

        html += '<div class="' + slotClass + '" ' +
          (isUnlocked && slot.state === 'empty' ? 'ondragover="onSlotDragOver(event, ' + i + ')" ondragleave="onSlotDragLeave(event)" ondrop="onSlotDrop(event, ' + i + ')"' : '') +
          '>';

        html += '<div class="slot-header">' +
          '<span class="slot-num">Slot ' + (i + 1) + '</span>' +
          '<span class="slot-status status-' + (isUnlocked ? slot.state : 'locked') + '">' +
            (isUnlocked ? slot.state : 'Locked') +
          '</span>' +
        '</div>';

        html += '<div class="slot-content">';

        if (!isUnlocked) {
          let req = i < 4 ? 'Contractor I' : (i < 7 ? 'Contractor II' : 'Contractor III');
          html += '<div class="slot-locked-text">&#x1F512;</div>' +
            '<div class="slot-locked-req">Unlock with ' + req + '</div>';
        } else if (slot.state === 'empty') {
          html += '<div class="slot-empty-text">Drag a contract here</div>';
        } else if (slot.state === 'pending' && slot.contract) {
          html += renderSlotContract(slot, i, false);
          html += '<div class="slot-buttons">' +
            '<button class="btn btn-accept" onclick="acceptContract(' + i + ')">Accept</button>' +
            '<button class="btn btn-remove" onclick="removeContract(' + i + ')">Remove</button>' +
          '</div>';
        } else if (slot.state === 'active' && slot.contract) {
          html += '<div class="slot-timer" id="slot-timer-' + i + '">' + formatTime(slot.endTime - Date.now()) + '</div>';
          html += renderSlotContract(slot, i, true);
          const canFill = canFillContract(slot);
          html += '<div class="slot-buttons">' +
            '<button class="btn btn-fill" ' + (canFill && !actionPending ? 'onclick="fillContract(' + i + ')"' : 'disabled') + '>Fill Order</button>' +
          '</div>';
        } else if (slot.state === 'cooldown') {
          html += '<div class="slot-cooldown-timer">Available in <span id="slot-timer-' + i + '">' + formatTime(slot.endTime - Date.now()) + '</span></div>';
        }

        html += '</div></div>';
      });

      container.innerHTML = html;
    }

    function renderSlotContract(slot, slotIndex, showProgress) {
      let html = '<div class="slot-contract">';
      html += '<div class="items">';
      slot.contract.items.forEach(item => {
        const owned = gameState.inventory[item.key] || 0;
        const hasEnough = owned >= item.qty;
        html += '<div class="item">' +
          '<span class="item-icon">' + item.icon + '</span>' +
          '<span class="item-qty ' + (showProgress ? (hasEnough ? 'has-enough' : 'not-enough') : '') + '">' +
            (showProgress ? owned + '/' : 'x') + item.qty +
          '</span>' +
        '</div>';
      });
      html += '</div>';
      html += '<div class="rewards">' +
        '<span class="reward-gold">&#x1F4B0; ' + slot.contract.goldReward + 'g</span>' +
        '<span class="reward-xp">&#x2B50; ' + slot.contract.xpReward + ' XP</span>' +
      '</div>';
      html += '</div>';
      return html;
    }

    // ============================================
    // NOTIFICATIONS & SOUND
    // ============================================

    function notify(message, type) {
      if (notificationTimeout) clearTimeout(notificationTimeout);
      const existing = document.querySelector('.notification');
      if (existing) existing.remove();

      const div = document.createElement('div');
      div.className = 'notification ' + type;
      div.textContent = message;
      document.body.appendChild(div);
      notificationTimeout = setTimeout(() => div.remove(), 3000);
    }

    var _clickSound = new Audio('click.mp3');
    _clickSound.preload = 'auto';
    _clickSound.volume = 0.3;
    function playSound() {
      try { _clickSound.currentTime = 0; _clickSound.play().catch(function(){}); } catch(e) {}
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    let lastMessageId = '';
    let lastMessageTime = 0;

    function processMessage(msg, source) {
      const now = Date.now();
      const msgId = msg + '_' + Math.floor(now / 100);
      if (msgId === lastMessageId && now - lastMessageTime < 200) return;
      lastMessageId = msgId;
      lastMessageTime = now;
      handlePortalsMessage(msg);
    }

    function setupMessageListener() {
      if (typeof PortalsSdk !== 'undefined' && PortalsSdk.setMessageListener) {
        PortalsSdk.setMessageListener(function(msg) { processMessage(msg, 'SDK'); });
        console.log('[Contracts] SDK listener registered');
        // Trigger sync now that SDK is ready
        setTimeout(function() { triggerTask('Sync_Inventory'); }, 100);
      } else {
        console.log('[Contracts] Waiting for SDK...');
        setTimeout(setupMessageListener, 100);
      }
    }

    window.addEventListener('message', function(event) {
      if (event.data && typeof event.data === 'string') {
        processMessage(event.data, 'postMessage');
      } else if (event.data && event.data.portalsMessage) {
        processMessage(event.data.portalsMessage, 'postMessage-portals');
      } else if (event.data && event.data.message && typeof event.data.message === 'string') {
        processMessage(event.data.message, 'postMessage-message');
      }
    });

    document.addEventListener('DOMContentLoaded', function() {
      setupMessageListener();
      setTimeout(function() { triggerTask('Sync_Inventory'); }, 300);
      render();
      setInterval(gameLoop, 1000);
    });

    document.addEventListener('visibilitychange', function() {
      if (!document.hidden) {
        triggerTask('Sync_Inventory');
        render();
      }
    });
  </script>
</body>
</html>
