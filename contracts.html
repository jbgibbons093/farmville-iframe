<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Hughberry Farms - Contracts Board</title>
  <link href="fonts.css" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Nunito', sans-serif; background: transparent; display: flex; justify-content: center; }
    .container { width: 100%; max-width: 700px; max-height: 90vh; background: linear-gradient(145deg, #1a2f1f 0%, #0d1a10 100%); border: 5px solid #3dff7f; border-radius: 22px; box-shadow: 0 0 40px rgba(61, 255, 127, 0.35), 0 0 80px rgba(46, 204, 113, 0.15), inset 0 1px 0 rgba(255,255,255,0.05); display: flex; flex-direction: column; overflow: hidden; }

    .header { background: linear-gradient(180deg, #34d073 0%, #22a84e 50%, #1e8449 100%); padding: 16px 22px; display: flex; justify-content: space-between; align-items: center; border-bottom: 3px solid rgba(0,0,0,0.2); }
    .title { font-family: 'Luckiest Guy', cursive; font-size: 28px; color: #fff; text-shadow: 2px 2px 0 #145a32, 0 0 10px rgba(255,255,255,0.2); letter-spacing: 2px; }
    .header-stats { display: flex; gap: 12px; align-items: center; }
    .stat-box { display: flex; align-items: center; gap: 6px; background: rgba(0,0,0,0.35); padding: 8px 14px; border-radius: 10px; border: 2px solid rgba(255,255,255,0.1); }
    .stat-icon { font-size: 19px; }
    .stat-value { font-size: 17px; font-weight: 800; color: #FFD700; text-shadow: 0 0 6px rgba(255, 215, 0, 0.4); }
    .close-btn { background: rgba(0,0,0,0.35); border: 2px solid rgba(255,255,255,0.3); color: #fff; width: 40px; height: 40px; border-radius: 10px; font-size: 20px; cursor: pointer; transition: all 0.15s cubic-bezier(0.34, 1.56, 0.64, 1); }
    .close-btn:hover { background: #c0392b; border-color: #e74c3c; box-shadow: 0 0 14px rgba(231, 76, 60, 0.5); transform: scale(1.08); }
    .close-btn:active { transform: scale(0.95); }

    .content { flex: 1; overflow: hidden; padding: 15px; display: flex; flex-direction: column; gap: 10px; }

    .panel-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 14px; background: rgba(46, 204, 113, 0.2); border: 2px solid #27ae60; border-radius: 10px; }
    .panel-title { font-size: 16px; font-weight: 800; color: #2ecc71; text-transform: uppercase; letter-spacing: 1px; }
    .panel-subtitle { font-size: 13px; color: #aaa; }
    .refresh-timer { display: flex; align-items: center; gap: 6px; font-size: 15px; color: #f39c12; font-weight: 800; text-shadow: 0 0 6px rgba(243, 156, 18, 0.3); }

    .slots-list { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; padding-right: 5px; margin-top: 10px; }

    /* Slot cards */
    .slot { background: linear-gradient(145deg, #1e3326 0%, #0f1a12 100%); border: 3px dashed #3d6b4f; border-radius: 14px; padding: 16px; transition: all 0.2s; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .slot.locked { opacity: 0.5; border-style: solid; }
    .slot.has-contract { border-style: solid; border-color: #27ae60; }
    .slot.active { border-color: #f39c12; box-shadow: 0 4px 12px rgba(243, 156, 18, 0.2); }
    .slot.cooldown { border-color: #555; }

    .slot-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .slot-num { font-size: 15px; color: #888; font-weight: 800; }
    .slot-timer-inline { font-size: 16px; font-weight: 800; color: #f39c12; text-shadow: 0 0 8px rgba(243, 156, 18, 0.4); letter-spacing: 0.5px; }
    .slot-status { font-size: 13px; padding: 6px 14px; border-radius: 8px; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; }
    .status-loading { background: #555; color: #aaa; }
    .status-available { background: #2980b9; color: #fff; box-shadow: 0 2px 6px rgba(41, 128, 185, 0.3); }
    .status-active { background: #f39c12; color: #000; box-shadow: 0 2px 6px rgba(243, 156, 18, 0.3); }
    .status-cooldown { background: #555; color: #aaa; }
    .status-locked { background: #333; color: #666; }

    .slot-content { display: flex; flex-direction: column; gap: 6px; }
    .slot-empty-text { font-size: 13px; color: #666; text-align: center; padding: 10px 0; }
    .slot-locked-text { font-size: 22px; text-align: center; }
    .slot-locked-req { font-size: 12px; color: #f39c12; text-align: center; font-weight: 700; }

    .slot-contract { width: 100%; }
    .slot-contract .items { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px; }
    .slot-contract .item { display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.45); padding: 10px 16px; border-radius: 10px; border: 2px solid rgba(255,255,255,0.1); flex: 1; min-width: 120px; }
    .slot-contract .item-icon { font-size: 28px; }
    .slot-contract .item-name { font-size: 16px; font-weight: 700; color: #ccc; }
    .slot-contract .item-qty { font-size: 20px; font-weight: 800; color: #fff; letter-spacing: 0.5px; margin-left: auto; }
    .slot-contract .item-qty.has-enough { color: #2ecc71; }
    .slot-contract .item-qty.not-enough { color: #e74c3c; }

    .slot-contract .rewards { display: flex; gap: 16px; margin-bottom: 10px; font-size: 20px; font-weight: 800; }
    .slot-contract .reward-gold { color: #FFD700; text-shadow: 0 0 8px rgba(255, 215, 0, 0.5); }
    .slot-contract .reward-xp { color: #b06cdb; text-shadow: 0 0 8px rgba(155, 89, 182, 0.4); }

    .slot-buttons { display: flex; gap: 10px; }
    .btn { padding: 14px 0; border-radius: 12px; font-size: 18px; font-weight: 800; cursor: pointer; transition: all 0.15s cubic-bezier(0.34, 1.56, 0.64, 1); border: 3px solid; position: relative; width: 100%; text-transform: uppercase; letter-spacing: 1px; }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
    .btn-accept { background: linear-gradient(180deg, #34d073 0%, #1e8449 100%); border-color: #2ecc71; color: #fff; box-shadow: 0 5px 0 #166534; }
    .btn-accept:hover:not(:disabled) { transform: scale(1.04) translateY(-3px); box-shadow: 0 8px 0 #166534, 0 0 20px rgba(46, 204, 113, 0.5); }
    .btn-accept:active:not(:disabled) { transform: scale(0.97) translateY(3px); box-shadow: 0 1px 0 #166534; }
    .btn-fill { background: linear-gradient(180deg, #f5ab1e 0%, #d68910 100%); border-color: #f1c40f; color: #fff; box-shadow: 0 5px 0 #a06b0a; }
    .btn-fill:hover:not(:disabled) { transform: scale(1.04) translateY(-3px); box-shadow: 0 8px 0 #a06b0a, 0 0 20px rgba(241, 196, 15, 0.5); }
    .btn-fill:active:not(:disabled) { transform: scale(0.97) translateY(3px); box-shadow: 0 1px 0 #a06b0a; }

    .notification { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 16px 30px; border-radius: 14px; font-size: 16px; font-weight: 800; z-index: 1000; animation: slideIn 0.3s ease; box-shadow: 0 6px 24px rgba(0,0,0,0.4); }
    .notification.success { background: linear-gradient(180deg, #34d073 0%, #1e8449 100%); color: #fff; border: 2px solid #3dff7f; }
    .notification.error { background: linear-gradient(180deg, #e74c3c 0%, #b33025 100%); color: #fff; border: 2px solid #ff6b5a; }
    @keyframes slideIn { from { opacity: 0; top: 0; } to { opacity: 1; top: 20px; } }

    ::-webkit-scrollbar { width: 10px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.25); border-radius: 5px; }
    ::-webkit-scrollbar-thumb { background: linear-gradient(180deg, #34d073, #1e8449); border-radius: 5px; border: 2px solid rgba(0,0,0,0.2); }
    ::-webkit-scrollbar-thumb:hover { background: linear-gradient(180deg, #3dff7f, #27ae60); }
  </style>
</head>
<body>
<script>var _uiPopCtx=null;var _uiPopBuf=null;var _uiPopPlayed=false;try{_uiPopCtx=new(window.AudioContext||window.webkitAudioContext)();fetch('ui-pop.mp3').then(function(r){return r.arrayBuffer()}).then(function(b){return _uiPopCtx.decodeAudioData(b)}).then(function(d){_uiPopBuf=d}).catch(function(){})}catch(e){}</script>
  <div class="container">
    <div class="header">
      <div class="title">CONTRACTS</div>
      <div class="header-stats">
        <div class="stat-box">
          <span class="stat-icon">&#x1FA99;</span>
          <span class="stat-value" id="gold-display">0</span>
        </div>
        <div class="stat-box">
          <span class="stat-icon">&#x2B50;</span>
          <span class="stat-value">Lv.<span id="level-display">0</span></span>
        </div>
        <button class="close-btn" onclick="closeIframe()">&#x2715;</button>
      </div>
    </div>

    <div class="content">
      <div class="panel-header">
        <div>
          <div class="panel-title">Contracts Board</div>
          <div class="panel-subtitle"><span id="slots-unlocked">1</span> / 10 slots unlocked</div>
        </div>
        <div class="refresh-timer">
          <span>&#x1F504;</span>
          <span id="refresh-timer">2:00</span>
        </div>
      </div>
      <div class="slots-list" id="slots-list"></div>
    </div>
  </div>

  <script src="https://portals-labs.github.io/portals-sdk/portals-sdk.js"></script>
  <script>
    // ============================================
    // HUGHBERRY FARMS - CONTRACTS BOARD v3
    // Per-slot deterministic contracts with persistence
    // ============================================

    const REFRESH_MS = 2 * 60 * 1000; // 2 minutes
    // No fulfill timer — accepted contracts stay active until filled
    // No cooldown timer — slot immediately gets a new contract after filling
    // (Timers can't persist across iframe close/reopen since Portals blocks localStorage)

    // Items with their properties
    const ITEMS = {
      wheat: { name: 'Wheat', icon: '&#x1F33E;', value: 5, unlockLevel: 0, deductTask: 'Deduct_Crop_Wheat_1' },
      carrot: { name: 'Carrot', icon: '&#x1F955;', value: 10, unlockLevel: 7, deductTask: 'Deduct_Crop_Carrot_1' },
      corn: { name: 'Corn', icon: '&#x1F33D;', value: 8, unlockLevel: 3, deductTask: 'Deduct_Crop_Corn_1' },
      potato: { name: 'Potato', icon: '&#x1F954;', value: 12, unlockLevel: 10, deductTask: 'Deduct_Crop_Potato_1' },
      tomato: { name: 'Tomato', icon: '&#x1F345;', value: 15, unlockLevel: 16, deductTask: 'Deduct_Crop_Tomato_1' },
      pumpkin: { name: 'Pumpkin', icon: '&#x1F383;', value: 30, unlockLevel: 23, deductTask: 'Deduct_Crop_Pumpkin_1' },
      milk: { name: 'Milk', icon: '&#x1F95B;', value: 12, unlockLevel: 2, deductTask: 'Deduct_Milk_1' },
      egg: { name: 'Egg', icon: '&#x1F95A;', value: 8, unlockLevel: 6, deductTask: 'Deduct_Egg_1' },
      wool: { name: 'Wool', icon: '&#x1F9F6;', value: 15, unlockLevel: 13, deductTask: 'Deduct_Wool_1' },
      goat_meat: { name: 'Goat Meat', icon: '&#x1F356;', value: 20, unlockLevel: 18, deductTask: 'Deduct_Goat_Meat_1' },
      honey: { name: 'Honey', icon: '&#x1F36F;', value: 25, unlockLevel: 21, deductTask: 'Deduct_Honey_1' },
      truffle: { name: 'Truffle', icon: '&#x1F344;', value: 50, unlockLevel: 26, deductTask: 'Deduct_Truffle_1' },
      flour: { name: 'Flour', icon: '&#x1F35E;', value: 10, unlockLevel: 4, deductTask: 'Deduct_Flour_1' },
      butter: { name: 'Butter', icon: '&#x1F9C8;', value: 30, unlockLevel: 8, deductTask: 'Deduct_Butter_1' },
      cheese: { name: 'Cheese', icon: '&#x1F9C0;', value: 45, unlockLevel: 9, deductTask: 'Deduct_Cheese_1' },
      bread: { name: 'Bread', icon: '&#x1F956;', value: 35, unlockLevel: 11, deductTask: 'Deduct_Bread_1' },
      blanket: { name: 'Blanket', icon: '&#x1F9E3;', value: 60, unlockLevel: 14, deductTask: 'Deduct_Blanket_1' },
      stew: { name: 'Stew', icon: '&#x1F372;', value: 50, unlockLevel: 15, deductTask: 'Deduct_Stew_1' },
      ragout: { name: 'Ragout', icon: '&#x1F356;', value: 75, unlockLevel: 19, deductTask: 'Deduct_Ragout_1' },
      mead: { name: 'Mead', icon: '&#x1F37A;', value: 100, unlockLevel: 22, deductTask: 'Deduct_Mead_1' },
      pie: { name: 'Pie', icon: '&#x1F967;', value: 100, unlockLevel: 24, deductTask: 'Deduct_Pie_1' },
      meat_pie: { name: 'Meat Pie', icon: '&#x1F969;', value: 90, unlockLevel: 27, deductTask: 'Deduct_Meat_Pie_1' },
      cake: { name: 'Cake', icon: '&#x1F370;', value: 150, unlockLevel: 28, deductTask: 'Deduct_Cake_1' }
    };

    const TIER_CONFIG = {
      1: { minLevel: 0, maxLevel: 9, goldMult: 1.0, xpMult: 1.0 },
      2: { minLevel: 10, maxLevel: 19, goldMult: 1.5, xpMult: 1.5 },
      3: { minLevel: 20, maxLevel: 29, goldMult: 2.0, xpMult: 2.0 },
      4: { minLevel: 30, maxLevel: 39, goldMult: 2.5, xpMult: 2.5 },
      5: { minLevel: 40, maxLevel: 50, goldMult: 3.0, xpMult: 3.0 }
    };

    let gameState = {
      gold: 0,
      level: 0,
      xp: 0,
      inventory: {},
      talents: { contractor1: 0, contractor2: 0, contractor3: 0 },
      rebirthBlessings: { quickContracts: 0, timeWarp: 0 },
      contractDone: [0,0,0,0,0,0,0,0,0,0] // Contract_1_Done through Contract_10_Done
    };

    let refreshEndTime = getRefreshWindow().endTime;
    let lastWindowSeed = null;
    let syncReceived = false; // Don't render slots until first Sync_Inventory

    // Player's 10 slots — state is derived from Contract_X_Done + deterministic seed
    // States: 'loading' (waiting for sync), 'available' (has a contract to accept),
    //         'active' (accepted, fulfilling), 'locked'
    let slots = [];
    for (let i = 0; i < 10; i++) {
      slots.push({
        id: i + 1,
        state: 'loading',
        contract: null,
        frozenContract: null, // Deep copy frozen on accept — NEVER regenerated
        endTime: null,
        windowSeed: null, // which 2-min window generated this slot's contract
        frozenLevel: null, // level when contract was accepted — used for restore
        fillCount: 0 // incremented on each fill — changes the seed for next contract
      });
    }

    let actionPending = false;
    let notificationTimeout = null;

    // ============================================
    // SEEDED PRNG (mulberry32) - deterministic contracts per slot per time window
    // ============================================

    function mulberry32(seed) {
      return function() {
        seed |= 0;
        seed = seed + 0x6D2B79F5 | 0;
        var t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function getEffectiveRefreshMs() {
      // QuickContracts: -30% per rank (max 3), TimeWarp: -5% per rank (max 2)
      var qc = gameState.rebirthBlessings.quickContracts || 0;
      var tw = gameState.rebirthBlessings.timeWarp || 0;
      var reduction = 1 - (qc * 0.30) - (tw * 0.05);
      return Math.max(5000, Math.floor(REFRESH_MS * reduction));
    }

    function getRefreshWindow() {
      var ms = getEffectiveRefreshMs();
      var now = Date.now();
      var windowIndex = Math.floor(now / ms);
      var windowEnd = (windowIndex + 1) * ms;
      return { seed: windowIndex, endTime: windowEnd };
    }

    // Generate a deterministic contract for a specific slot in a specific window
    // NOTE: level is NOT part of the seed — level changes must not alter existing contracts
    // fillCount ensures a new contract after each fill within the same window
    function getSlotContract(slotIndex, windowSeed) {
      var fc = slots[slotIndex] ? slots[slotIndex].fillCount : 0;
      var rng = mulberry32(windowSeed * 997 + slotIndex * 7919 + fc * 104729);
      return generateContract(gameState.level, rng);
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    function getTier(level) {
      if (level >= 40) return 5;
      if (level >= 30) return 4;
      if (level >= 20) return 3;
      if (level >= 10) return 2;
      return 1;
    }

    function getUnlockedSlots() {
      const t = gameState.talents;
      return 1 + t.contractor1 + t.contractor2 + t.contractor3;
    }

    function getAvailableItems(level) {
      return Object.entries(ITEMS)
        .filter(function(entry) { return entry[1].unlockLevel <= level; })
        .map(function(entry) { return { key: entry[0], name: entry[1].name, icon: entry[1].icon, value: entry[1].value, unlockLevel: entry[1].unlockLevel, deductTask: entry[1].deductTask }; });
    }

    function generateContract(level, rng) {
      const tier = getTier(level);
      const tierConfig = TIER_CONFIG[tier];
      const availableItems = getAvailableItems(level);
      if (availableItems.length === 0) return null;

      const numItems = rng() < 0.7 ? 1 : 2;
      const selectedItems = [];
      const usedIndices = new Set();

      for (let i = 0; i < numItems && i < availableItems.length; i++) {
        let idx;
        do {
          idx = Math.floor(rng() * availableItems.length);
        } while (usedIndices.has(idx) && usedIndices.size < availableItems.length);
        usedIndices.add(idx);

        const item = availableItems[idx];
        const maxQty = Math.max(2, Math.floor(100 / item.value));
        const qty = Math.max(1, Math.floor(rng() * maxQty) + 1);
        selectedItems.push({ key: item.key, name: item.name, icon: item.icon, value: item.value, deductTask: item.deductTask, qty: qty });
      }

      const baseCost = selectedItems.reduce(function(sum, item) { return sum + item.value * item.qty; }, 0);
      var qcBonus = (gameState.rebirthBlessings.quickContracts || 0) * 0.5;
      const profitMult = (1.25 + qcBonus) + (rng() * 0.5);
      const rawGold = baseCost * profitMult;
      const goldReward = Math.max(25, Math.round(rawGold / 25) * 25);
      const xpReward = Math.floor(goldReward * 0.3);

      return { items: selectedItems, goldReward: goldReward, xpReward: xpReward, tier: tier };
    }

    // Refresh all available (non-active) slots with new contracts
    function refreshSlotContracts() {
      var win = getRefreshWindow();
      lastWindowSeed = win.seed;
      refreshEndTime = win.endTime;

      var unlockedCount = getUnlockedSlots();
      for (var i = 0; i < 10; i++) {
        var slot = slots[i];
        // Only regenerate contracts for available slots (not active)
        if (i < unlockedCount && slot.state === 'available') {
          slot.contract = getSlotContract(i, win.seed);
          slot.windowSeed = win.seed;
        }
      }

      console.log('[Contracts] Refreshed slot contracts - seed:', win.seed, 'level:', gameState.level);
      render();
    }

    function formatTime(ms) {
      if (ms <= 0) return '0:00';
      const totalSec = Math.ceil(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return min + ':' + (sec < 10 ? '0' : '') + sec;
    }

    // ============================================
    // PORTALS COMMUNICATION
    // ============================================

    function triggerTask(taskName) {
      if (typeof PortalsSdk !== 'undefined' && PortalsSdk.sendMessageToUnity) {
        PortalsSdk.sendMessageToUnity(JSON.stringify({ TaskName: taskName, TaskTargetState: 'SetNotActiveToActive' }));
        console.log('[Contracts] Triggered task:', taskName);
      } else {
        console.log('[Contracts] SDK not ready, cannot trigger:', taskName);
      }
    }

    function closeIframe() {
      playSound();
      if (typeof PortalsSdk !== 'undefined' && PortalsSdk.closeIframe) {
        PortalsSdk.closeIframe();
      }
    }

    // ============================================
    // SYNC INVENTORY PARSER
    // ============================================

    const varMapping = {
      // Root state
      'Gold': { target: 'gold' },
      'Level': { target: 'level' },
      'XP': { target: 'xp' },
      'playerName': { target: '_skip' },
      // Seeds (2-word) - skip
      'Seeds_Wheat': { target: '_skip' }, 'Seeds_Carrot': { target: '_skip' },
      'Seeds_Corn': { target: '_skip' }, 'Seeds_Potato': { target: '_skip' },
      'Seeds_Tomato': { target: '_skip' }, 'Seeds_Pumpkin': { target: '_skip' },
      // Crops (2-word)
      'Crop_Wheat': { target: 'wheat' },
      'Crop_Carrot': { target: 'carrot' },
      'Crop_Corn': { target: 'corn' },
      'Crop_Potato': { target: 'potato' },
      'Crop_Tomato': { target: 'tomato' },
      'Crop_Pumpkin': { target: 'pumpkin' },
      // Animal products (1-word and 2-word)
      'Milk': { target: 'milk' },
      'Egg': { target: 'egg' },
      'Wool': { target: 'wool' },
      'Goat_Meat': { target: 'goat_meat' },
      'Truffle': { target: 'truffle' },
      'Honey': { target: 'honey' },
      // Crafted items (1-word and 2-word)
      'Flour': { target: 'flour' },
      'Bread': { target: 'bread' },
      'Cheese': { target: 'cheese' },
      'Stew': { target: 'stew' },
      'Ragout': { target: 'ragout' },
      'Pie': { target: 'pie' },
      'Meat_Pie': { target: 'meat_pie' },
      'Blanket': { target: 'blanket' },
      'Butter': { target: 'butter' },
      'Cake': { target: 'cake' },
      'Mead': { target: 'mead' },
      // Equipment flags - skip
      'Has_Beesuit': { target: '_skip' }, 'Has_Basket': { target: '_skip' },
      'Has_Milk_Pail': { target: '_skip' }, 'Has_Shearing_Kit': { target: '_skip' },
      'Has_Butcher_Knife': { target: '_skip' }, 'Has_Truffle_Spade': { target: '_skip' },
      'Has_Starter_Seeds': { target: '_skip' },
      // Recipe flags - skip
      'Has_Recipe_Flour': { target: '_skip' }, 'Has_Recipe_Bread': { target: '_skip' },
      'Has_Recipe_Cheese': { target: '_skip' }, 'Has_Recipe_Stew': { target: '_skip' },
      'Has_Recipe_Ragout': { target: '_skip' }, 'Has_Recipe_Pie': { target: '_skip' },
      'Has_Recipe_Blanket': { target: '_skip' }, 'Has_Recipe_Butter': { target: '_skip' },
      'Has_Recipe_Cake': { target: '_skip' }, 'Has_Recipe_Mead': { target: '_skip' },
      'Has_Recipe_Meat_Pie': { target: '_skip' },
      // Talent variables - skip (except contractors)
      'T_PlotRow2': { target: '_skip' }, 'T_GreenThumb': { target: '_skip' },
      'T_EagerPlanter': { target: '_skip' }, 'T_PlotRow3': { target: '_skip' },
      'T_BountifulHarvest': { target: '_skip' }, 'T_RapidGrowth': { target: '_skip' },
      'T_PlotRow4': { target: '_skip' }, 'T_CropMastery': { target: '_skip' },
      'T_CowHerd': { target: '_skip' }, 'T_ChickenFlock': { target: '_skip' },
      'T_QuickHands': { target: '_skip' }, 'T_SheepPen': { target: '_skip' },
      'T_GoatYard': { target: '_skip' }, 'T_ApiaryExpansion': { target: '_skip' },
      'T_HusbandryKnowledge': { target: '_skip' }, 'T_PigSty': { target: '_skip' },
      'T_AnimalMastery': { target: '_skip' }, 'T_KeenLearner': { target: '_skip' },
      'T_FarmHand': { target: '_skip' }, 'T_Stockman': { target: '_skip' },
      'T_Artisan': { target: '_skip' }, 'T_SeasonedWorker': { target: '_skip' },
      'T_BonusPoint1': { target: '_skip' }, 'T_Prodigy': { target: '_skip' },
      'T_BonusPoint2': { target: '_skip' },
      // Contractor talents - these we need
      'T_Contractor1': { target: 't_contractor1' },
      'T_Contractor2': { target: 't_contractor2' },
      'T_Contractor3': { target: 't_contractor3' },
      'RT_QuickContracts': { target: 'rt_quickcontracts' },
      'RT_TimeWarp': { target: 'rt_timewarp' },
      'Rebirth_Shards': { target: '_skip' }, 'Mystic_Essence': { target: '_skip' },
      'RT_FleetHarvest': { target: '_skip' }, 'RT_SwiftHusbandry': { target: '_skip' },
      'RT_RushingWinds': { target: '_skip' }, 'RT_NimbleHands': { target: '_skip' },
      'RT_Windfall': { target: '_skip' }, 'RT_GreenFingers': { target: '_skip' },
      'RT_Stockpiler': { target: '_skip' }, 'RT_ArtisanTouch': { target: '_skip' },
      'RT_Fortune': { target: '_skip' }, 'RT_Cornucopia': { target: '_skip' },
      'RT_NestEgg': { target: '_skip' }, 'RT_SeedVault': { target: '_skip' },
      'RT_Seasoned': { target: '_skip' }, 'RT_ToolShed': { target: '_skip' },
      'RT_RecipeTome': { target: '_skip' }, 'RT_QuickStart': { target: '_skip' },
      // Other
      'Unspent_Talent_Points': { target: '_skip' },
      'Rebirth_Count': { target: '_skip' },
      // Contract done flags - we need these now!
      'Contract_1_Done': { target: 'cd1' }, 'Contract_2_Done': { target: 'cd2' },
      'Contract_3_Done': { target: 'cd3' }, 'Contract_4_Done': { target: 'cd4' },
      'Contract_5_Done': { target: 'cd5' }, 'Contract_6_Done': { target: 'cd6' },
      'Contract_7_Done': { target: 'cd7' }, 'Contract_8_Done': { target: 'cd8' },
      'Contract_9_Done': { target: 'cd9' }, 'Contract_10_Done': { target: 'cd10' }
    };

    function parseSyncInventory(msg) {
      const data = {};
      const parts = msg.replace('Sync_Inventory_', '').split('_');
      let i = 0;

      while (i < parts.length) {
        let matched = false;

        // 4-word keys (Has_Recipe_Meat_Pie)
        if (i + 4 < parts.length) {
          const k4 = parts[i] + '_' + parts[i+1] + '_' + parts[i+2] + '_' + parts[i+3];
          if (varMapping[k4]) {
            if (varMapping[k4].target !== '_skip') {
              const val = parseInt(parts[i+4]);
              data[varMapping[k4].target] = Math.max(0, isNaN(val) ? 0 : val);
            }
            i += 5; matched = true;
          }
        }

        // 3-word keys
        if (!matched && i + 3 < parts.length) {
          const k3 = parts[i] + '_' + parts[i+1] + '_' + parts[i+2];
          if (varMapping[k3]) {
            if (varMapping[k3].target !== '_skip') {
              const val = parseInt(parts[i+3]);
              data[varMapping[k3].target] = Math.max(0, isNaN(val) ? 0 : val);
            }
            i += 4; matched = true;
          }
        }

        // 2-word keys
        if (!matched && i + 2 < parts.length) {
          const k2 = parts[i] + '_' + parts[i+1];
          if (varMapping[k2]) {
            if (varMapping[k2].target !== '_skip') {
              const val = parseInt(parts[i+2]);
              data[varMapping[k2].target] = Math.max(0, isNaN(val) ? 0 : val);
            }
            i += 3; matched = true;
          }
        }

        // 1-word keys
        if (!matched && i + 1 < parts.length) {
          const k1 = parts[i];
          if (varMapping[k1]) {
            if (varMapping[k1].target !== '_skip') {
              const val = parseInt(parts[i+1]);
              data[varMapping[k1].target] = Math.max(0, isNaN(val) ? 0 : val);
            }
            i += 2; matched = true;
          }
        }

        if (!matched) i++;
      }

      return data;
    }

    var _prevXP = -1, _prevLevel = -1, _firstXPSync = true;

    function handlePortalsMessage(msg) {
      if (typeof msg !== 'string') return;
      if (msg.indexOf('Sync_Inventory') !== 0) return;

      console.log('[Contracts] Received Sync_Inventory');
      const data = parseSyncInventory(msg);

      gameState.gold = data.gold !== undefined ? data.gold : 0;
      gameState.level = data.level !== undefined ? data.level : 0;
      gameState.xp = data.xp !== undefined ? data.xp : 0;

      // Map inventory items
      Object.keys(ITEMS).forEach(function(key) {
        gameState.inventory[key] = data[key] !== undefined ? data[key] : 0;
      });

      gameState.talents.contractor1 = data.t_contractor1 !== undefined ? data.t_contractor1 : 0;
      gameState.talents.contractor2 = data.t_contractor2 !== undefined ? data.t_contractor2 : 0;
      gameState.talents.contractor3 = data.t_contractor3 !== undefined ? data.t_contractor3 : 0;
      gameState.rebirthBlessings.quickContracts = data.rt_quickcontracts !== undefined ? data.rt_quickcontracts : 0;
      gameState.rebirthBlessings.timeWarp = data.rt_timewarp !== undefined ? data.rt_timewarp : 0;

      // Parse Contract_X_Done flags
      for (var ci = 0; ci < 10; ci++) {
        var key = 'cd' + (ci + 1);
        gameState.contractDone[ci] = data[key] !== undefined ? data[key] : 0;
      }

      console.log('[Contracts] Contract done flags:', gameState.contractDone);

      // Restore slots from Contract_X_Done flags
      // If Contract_X_Done = 1, that slot is accepted/active with its deterministic contract
      var win = getRefreshWindow();
      var windowChanged = (lastWindowSeed !== win.seed);
      lastWindowSeed = win.seed;
      refreshEndTime = win.endTime;

      var unlockedCount = getUnlockedSlots();
      for (var si = 0; si < 10; si++) {
        var slot = slots[si];

        if (si >= unlockedCount) {
          slot.state = 'locked';
          slot.contract = null;
          slot.endTime = null;
          continue;
        }

        if (slot.state === 'filling') {
          // Currently being fulfilled — don't touch
        } else if (slot.state === 'active' && slot.frozenContract) {
          // Slot is locally accepted with a frozen contract — NEVER touch it
          // Doesn't matter what Contract_X_Done says
        } else if (gameState.contractDone[si] === 1) {
          // Portals says this slot is accepted but we don't have local state
          // (iframe was reopened) — restore with frozen data if available
          slot.state = 'active';
          if (slot.frozenContract) {
            slot.contract = slot.frozenContract;
          } else {
            // Best effort: regenerate (won't match original if level changed)
            var contractSeed = slot.windowSeed || win.seed;
            slot.contract = getSlotContract(si, contractSeed);
            slot.frozenContract = JSON.parse(JSON.stringify(slot.contract));
            slot.windowSeed = contractSeed;
          }
          slot.endTime = null;
        } else {
          // Contract_X_Done = 0 and not locally active
          if (slot.state === 'active') {
            // Edge case: was active but frozenContract is null (shouldn't happen)
            // Keep active to be safe
          } else {
            // Available or loading — show a contract to accept
            var wasLoading = (slot.state === 'loading');
            slot.state = 'available';
            if (!slot.contract || wasLoading || windowChanged) {
              slot.contract = getSlotContract(si, win.seed);
              slot.windowSeed = win.seed;
            }
            slot.endTime = null;
          }
        }
      }

      syncReceived = true;

      // XP sound delta tracking
      if (_firstXPSync) { _firstXPSync = false; _prevXP = gameState.xp; _prevLevel = gameState.level; }
      else { if (gameState.level === _prevLevel && gameState.xp > _prevXP) { setTimeout(function() { try { _xpSound.currentTime = 0; _xpSound.play().catch(function(){}); } catch(e) {} }, 500); } _prevXP = gameState.xp; _prevLevel = gameState.level; }

      actionPending = false;
      render();
    }

    // ============================================
    // SLOT ACTIONS
    // ============================================

    function acceptContract(slotIndex) {
      var slot = slots[slotIndex];
      if (slot.state !== 'available' || !slot.contract) return;

      slot.state = 'active';
      slot.endTime = null;
      // Freeze a deep copy of the contract — this copy is NEVER regenerated
      slot.frozenContract = JSON.parse(JSON.stringify(slot.contract));
      slot.frozenLevel = gameState.level;

      // Tell Portals this slot is taken
      triggerTask('Complete_Contract_' + (slotIndex + 1));

      playSound();
      render();
    }

    function getActiveContract(slot) {
      // Always use frozenContract for active slots
      return (slot.state === 'active' && slot.frozenContract) ? slot.frozenContract : slot.contract;
    }

    function canFillContract(slot) {
      var contract = getActiveContract(slot);
      if (!contract || slot.state !== 'active' || actionPending) return false;
      return contract.items.every(function(item) {
        var owned = gameState.inventory[item.key] || 0;
        return owned >= item.qty;
      });
    }

    var _fillLock = {};
    function fillContract(slotIndex) {
      if (_fillLock[slotIndex]) return;
      var slot = slots[slotIndex];
      if (!canFillContract(slot)) return;

      _fillLock[slotIndex] = true;
      actionPending = true;

      // Immediately change state so no further clicks can process
      slot.state = 'filling';
      render();

      playSound();

      var contract = getActiveContract(slot);

      // Optimistically deduct items
      contract.items.forEach(function(item) {
        gameState.inventory[item.key] = (gameState.inventory[item.key] || 0) - item.qty;
      });

      // Build task list
      var deductTasks = [];
      contract.items.forEach(function(item) {
        for (var j = 0; j < item.qty; j++) {
          deductTasks.push(item.deductTask);
        }
      });

      var goldTasks = getRewardTasks(contract.goldReward, 'Add_Gold_', [1000, 500, 250, 100, 50, 25]);
      var xpTasks = getRewardTasks(contract.xpReward, 'Add_XP_', [500, 250, 100, 50, 25, 10]);

      var delay = 0;
      var STAGGER = 200;

      deductTasks.forEach(function(task) { setTimeout(function() { triggerTask(task); }, delay); delay += STAGGER; });
      goldTasks.forEach(function(task) { setTimeout(function() { triggerTask(task); }, delay); delay += STAGGER; });
      xpTasks.forEach(function(task) { setTimeout(function() { triggerTask(task); }, delay); delay += STAGGER; });

      // Clear the contract done flag in Portals
      setTimeout(function() { triggerTask('Clear_Contract_' + (slotIndex + 1)); }, delay);
      delay += STAGGER;

      notify('Contract fulfilled! +' + contract.goldReward + 'g +' + contract.xpReward + ' XP', 'success');

      // Keep slot in 'filling' state until ALL tasks have fired, THEN unlock
      var totalTasks = deductTasks.length + goldTasks.length + xpTasks.length + 1;
      var unlockDelay = (totalTasks * STAGGER) + 500;
      setTimeout(function() {
        var win = getRefreshWindow();
        slot.state = 'available';
        slot.frozenContract = null;
        slot.frozenLevel = null;
        slot.fillCount = (slot.fillCount || 0) + 1;
        slot.contract = getSlotContract(slotIndex, win.seed);
        slot.windowSeed = win.seed;
        slot.endTime = null;
        _fillLock[slotIndex] = false;
        actionPending = false;
        render();
      }, unlockDelay);
    }

    function getRewardTasks(amount, prefix, denominations) {
      var tasks = [];
      var remaining = amount;
      for (var d = 0; d < denominations.length; d++) {
        while (remaining >= denominations[d]) {
          tasks.push(prefix + denominations[d]);
          remaining -= denominations[d];
        }
      }
      return tasks;
    }

    // ============================================
    // GAME LOOP
    // ============================================

    var gameLoopInterval = null;

    function startGameLoop() {
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      gameLoopInterval = setInterval(gameLoop, 1000);
    }

    function gameLoop() {
      var now = Date.now();

      // Check if we've entered a new 2-minute window
      var win = getRefreshWindow();
      if (lastWindowSeed !== null && lastWindowSeed !== win.seed) {
        // New window — refresh available slots
        lastWindowSeed = win.seed;
        refreshEndTime = win.endTime;

        var unlockedCount = getUnlockedSlots();
        for (var i = 0; i < 10; i++) {
          if (i < unlockedCount && slots[i].state === 'available') {
            slots[i].fillCount = 0;
            slots[i].contract = getSlotContract(i, win.seed);
            slots[i].windowSeed = win.seed;
          }
        }
        render();
      }
      refreshEndTime = win.endTime;

      updateTimers();
    }

    function updateTimers() {
      var now = Date.now();

      // Refresh timer
      if (refreshEndTime) {
        var el = document.getElementById('refresh-timer');
        if (el) el.textContent = formatTime(refreshEndTime - now);
      }

    }

    // ============================================
    // RENDER
    // ============================================

    function render() {
      document.getElementById('gold-display').textContent = gameState.gold.toLocaleString();
      document.getElementById('level-display').textContent = gameState.level;
      document.getElementById('slots-unlocked').textContent = getUnlockedSlots();
      renderSlots();
    }

    function renderSlots() {
      var container = document.getElementById('slots-list');
      var unlockedCount = getUnlockedSlots();
      var html = '';

      slots.forEach(function(slot, i) {
        var isUnlocked = i < unlockedCount;
        var slotClass = 'slot' +
          (slot.state === 'active' ? ' has-contract active' : '') +
          (slot.state === 'available' && slot.contract ? ' has-contract' : '') +
          (!isUnlocked ? ' locked' : '');

        html += '<div class="' + slotClass + '">';

        // Header
        html += '<div class="slot-header">';
        html += '<span class="slot-num">Slot ' + (i + 1) + '</span>';
        var statusLabel = isUnlocked ? slot.state : 'locked';
        html += '<span class="slot-status status-' + statusLabel + '">' + statusLabel + '</span>';
        html += '</div>';

        html += '<div class="slot-content">';

        if (!isUnlocked) {
          var req = i < 4 ? 'Contractor I' : (i < 7 ? 'Contractor II' : 'Contractor III');
          html += '<div class="slot-locked-text">&#x1F512;</div>' +
            '<div class="slot-locked-req">Unlock with ' + req + '</div>';
        } else if (slot.state === 'available' && slot.contract) {
          // Show the contract with Accept button
          html += renderSlotContract(slot, i, false);
          html += '<div class="slot-buttons">' +
            '<button class="btn btn-accept" onclick="acceptContract(' + i + ')">Accept</button>' +
          '</div>';
        } else if (slot.state === 'filling') {
          // Briefly shown while fill tasks are firing
          html += '<div class="slot-empty-text" style="color:#f39c12;font-weight:800;">Filling order...</div>';
        } else if (slot.state === 'active' && getActiveContract(slot)) {
          // Show contract with progress and Fill button
          html += renderSlotContract(slot, i, true);
          var canFill = canFillContract(slot);
          html += '<div class="slot-buttons">' +
            '<button class="btn btn-fill" ' + (canFill && !actionPending ? 'onclick="fillContract(' + i + ')"' : 'disabled') + '>Fill Order</button>' +
          '</div>';
        } else {
          html += '<div class="slot-empty-text">Waiting for contract...</div>';
        }

        html += '</div></div>';
      });

      container.innerHTML = html;
    }

    function renderSlotContract(slot, slotIndex, showProgress) {
      var contract = getActiveContract(slot);
      var html = '<div class="slot-contract">';
      html += '<div class="items">';
      contract.items.forEach(function(item) {
        var owned = gameState.inventory[item.key] || 0;
        var hasEnough = owned >= item.qty;
        html += '<div class="item">' +
          '<span class="item-icon">' + item.icon + '</span>' +
          '<span class="item-name">' + item.name + '</span>' +
          '<span class="item-qty ' + (showProgress ? (hasEnough ? 'has-enough' : 'not-enough') : '') + '">' +
            (showProgress ? owned + '/' : 'x') + item.qty +
          '</span>' +
        '</div>';
      });
      html += '</div>';
      html += '<div class="rewards">' +
        '<span class="reward-gold">' + contract.goldReward + 'g</span>' +
        '<span class="reward-xp">' + contract.xpReward + ' XP</span>' +
      '</div>';
      html += '</div>';
      return html;
    }

    // ============================================
    // NOTIFICATIONS & SOUND
    // ============================================

    function notify(message, type) {
      if (notificationTimeout) clearTimeout(notificationTimeout);
      var existing = document.querySelector('.notification');
      if (existing) existing.remove();

      var div = document.createElement('div');
      div.className = 'notification ' + type;
      div.textContent = message;
      document.body.appendChild(div);
      notificationTimeout = setTimeout(function() { div.remove(); }, 3000);
    }

    var _clickSound = new Audio('click.mp3');
    _clickSound.preload = 'auto';
    _clickSound.volume = 0.6;
    var _xpSound = new Audio('xp-gain.mp3');
    _xpSound.preload = 'auto';
    _xpSound.volume = 0.3;
    function playSound() {
      try { _clickSound.currentTime = 0; _clickSound.play().catch(function(){}); } catch(e) {}
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    let lastMessageId = '';
    let lastMessageTime = 0;

    function processMessage(msg, source) {
      if(!_uiPopPlayed){_uiPopPlayed=true;try{if(_uiPopCtx&&_uiPopBuf){if(_uiPopCtx.state==='suspended')_uiPopCtx.resume();var _s=_uiPopCtx.createBufferSource();var _g=_uiPopCtx.createGain();_s.buffer=_uiPopBuf;_g.gain.value=0.5;_s.connect(_g);_g.connect(_uiPopCtx.destination);_s.start(0)}}catch(e){}}
      const now = Date.now();
      const msgId = msg + '_' + Math.floor(now / 100);
      if (msgId === lastMessageId && now - lastMessageTime < 200) return;
      lastMessageId = msgId;
      lastMessageTime = now;
      handlePortalsMessage(msg);
    }

    function setupMessageListener() {
      if (typeof PortalsSdk !== 'undefined' && PortalsSdk.setMessageListener) {
        PortalsSdk.setMessageListener(function(msg) { processMessage(msg, 'SDK'); });
        console.log('[Contracts] SDK listener registered');
        setTimeout(function() { triggerTask('Sync_Inventory'); }, 100);
      } else {
        console.log('[Contracts] Waiting for SDK...');
        setTimeout(setupMessageListener, 100);
      }
    }

    window.addEventListener('message', function(event) {
      if (event.data && typeof event.data === 'string') {
        processMessage(event.data, 'postMessage');
      } else if (event.data && event.data.portalsMessage) {
        processMessage(event.data.portalsMessage, 'postMessage-portals');
      } else if (event.data && event.data.message && typeof event.data.message === 'string') {
        processMessage(event.data.message, 'postMessage-message');
      }
    });

    document.addEventListener('DOMContentLoaded', function() {
      setupMessageListener();

      // ESC to close
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') { e.preventDefault(); closeIframe(); }
      });

      // Refocus game keyboard — skip on interactive elements
      function _refocusGame(e) {
        if (document.hidden) return;
        if (e && e.target) {
          var tag = e.target.tagName;
          if (tag === 'BUTTON' || tag === 'SELECT' || tag === 'INPUT') return;
          if (e.target.closest && e.target.closest('button, select')) return;
        }
        if (typeof PortalsSdk !== 'undefined' && PortalsSdk.focusGameKeyboard) PortalsSdk.focusGameKeyboard();
      }
      document.addEventListener('click', _refocusGame);
      document.addEventListener('mouseup', _refocusGame);
      document.addEventListener('keydown', _refocusGame);
      setTimeout(function() { _refocusGame(null); }, 300);

      // Don't pre-initialize slots — wait for Sync_Inventory to know which are active
      // Just set up the refresh timer seed
      var win = getRefreshWindow();
      lastWindowSeed = win.seed;
      refreshEndTime = win.endTime;

      render();
      updateTimers();
      startGameLoop();
    });

    document.addEventListener('visibilitychange', function() {
      if (!document.hidden) {
        console.log('[Contracts] Visibility restored - restarting game loop');
        startGameLoop();
        triggerTask('Sync_Inventory');
        render();
      }
    });

    window.addEventListener('focus', function() {
      console.log('[Contracts] Window focused - restarting game loop');
      startGameLoop();
      gameLoop();
    });
  </script>
</body>
</html>
