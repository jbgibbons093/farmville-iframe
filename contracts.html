<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hughberry Farms - Contracts Board</title>
  <link href="https://fonts.googleapis.com/css2?family=Luckiest+Guy&family=Nunito:wght@600;700;800&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Nunito', sans-serif; background: transparent; display: flex; justify-content: center; }
    .container { width: 100%; max-width: 800px; max-height: 90vh; background: linear-gradient(145deg, #1a2f1f 0%, #0d1a10 100%); border: 4px solid #2ecc71; border-radius: 20px; box-shadow: 0 0 30px rgba(46, 204, 113, 0.3); display: flex; flex-direction: column; overflow: hidden; }

    .header { background: linear-gradient(180deg, #27ae60 0%, #1e8449 100%); padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; }
    .title { font-family: 'Luckiest Guy', cursive; font-size: 22px; color: #fff; text-shadow: 2px 2px 0 #145a32; letter-spacing: 2px; }
    .header-stats { display: flex; gap: 10px; align-items: center; }
    .stat-box { display: flex; align-items: center; gap: 6px; background: rgba(0,0,0,0.3); padding: 6px 12px; border-radius: 8px; }
    .stat-icon { font-size: 16px; }
    .stat-value { font-size: 14px; font-weight: 800; color: #FFD700; }
    .close-btn { background: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.3); color: #fff; width: 32px; height: 32px; border-radius: 8px; font-size: 18px; cursor: pointer; transition: all 0.2s; }
    .close-btn:hover { background: #c0392b; border-color: #e74c3c; }

    .content { flex: 1; overflow: hidden; padding: 15px; display: flex; gap: 15px; }

    /* Two-column layout */
    .left-panel { flex: 1; display: flex; flex-direction: column; min-width: 0; }
    .right-panel { flex: 1; display: flex; flex-direction: column; min-width: 0; }

    .panel-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: rgba(46, 204, 113, 0.2); border: 2px solid #27ae60; border-radius: 8px; margin-bottom: 10px; }
    .panel-title { font-size: 13px; font-weight: 800; color: #2ecc71; text-transform: uppercase; letter-spacing: 1px; }
    .panel-subtitle { font-size: 11px; color: #aaa; }
    .refresh-timer { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #f39c12; font-weight: 700; }

    /* Slots list (left panel) */
    .slots-list { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; padding-right: 5px; }

    /* Available contracts list (right panel) */
    .available-list { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 6px; padding-right: 5px; }

    /* Contract row (compact list item) */
    .contract-row { display: flex; align-items: center; gap: 8px; background: linear-gradient(145deg, #2d4a3a 0%, #1a2f22 100%); border: 2px solid #3d6b4f; border-radius: 8px; padding: 8px 12px; cursor: grab; transition: all 0.2s; user-select: none; }
    .contract-row:hover { border-color: #2ecc71; background: linear-gradient(145deg, #3d5a4a 0%, #2a3f32 100%); }
    .contract-row.dragging { opacity: 0.5; cursor: grabbing; }
    .contract-row .items { display: flex; gap: 6px; flex: 1; }
    .contract-row .item { display: flex; align-items: center; gap: 3px; background: rgba(0,0,0,0.3); padding: 3px 8px; border-radius: 4px; font-size: 12px; }
    .contract-row .item-icon { font-size: 16px; }
    .contract-row .item-qty { color: #fff; font-weight: 700; }
    .contract-row .arrow { color: #666; font-size: 14px; }
    .contract-row .rewards { display: flex; gap: 10px; font-size: 12px; font-weight: 700; }
    .contract-row .reward-gold { color: #FFD700; }
    .contract-row .reward-xp { color: #9b59b6; }

    /* Slot cards */
    .slot { background: linear-gradient(145deg, #1e3326 0%, #0f1a12 100%); border: 2px dashed #3d6b4f; border-radius: 10px; padding: 10px; transition: all 0.2s; }
    .slot.drag-over { border-color: #2ecc71; border-style: solid; background: rgba(46, 204, 113, 0.1); }
    .slot.locked { opacity: 0.5; border-style: solid; }
    .slot.has-contract { border-style: solid; border-color: #27ae60; }
    .slot.active { border-color: #f39c12; }
    .slot.cooldown { border-color: #555; }

    .slot-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
    .slot-num { font-size: 11px; color: #888; font-weight: 700; }
    .slot-timer-inline { font-size: 13px; font-weight: 800; color: #f39c12; }
    .slot-status { font-size: 9px; padding: 2px 6px; border-radius: 4px; font-weight: 700; text-transform: uppercase; }
    .status-empty { background: #333; color: #888; }
    .status-pending { background: #2980b9; color: #fff; }
    .status-active { background: #f39c12; color: #000; }
    .status-cooldown { background: #555; color: #aaa; }
    .status-locked { background: #333; color: #666; }

    .slot-content { display: flex; flex-direction: column; gap: 6px; }
    .slot-empty-text { font-size: 11px; color: #666; text-align: center; padding: 10px 0; }
    .slot-locked-text { font-size: 18px; text-align: center; }
    .slot-locked-req { font-size: 10px; color: #f39c12; text-align: center; }

    .slot-contract { width: 100%; }
    .slot-contract .items { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 6px; }
    .slot-contract .item { display: flex; align-items: center; gap: 3px; background: rgba(0,0,0,0.3); padding: 3px 6px; border-radius: 4px; }
    .slot-contract .item-icon { font-size: 14px; }
    .slot-contract .item-qty { font-size: 11px; font-weight: 700; }
    .slot-contract .item-qty.has-enough { color: #2ecc71; }
    .slot-contract .item-qty.not-enough { color: #e74c3c; }

    .slot-contract .rewards { display: flex; gap: 10px; margin-bottom: 6px; font-size: 11px; font-weight: 700; }
    .slot-contract .reward-gold { color: #FFD700; }
    .slot-contract .reward-xp { color: #9b59b6; }

    .slot-buttons { display: flex; gap: 6px; }
    .btn { padding: 6px 12px; border-radius: 5px; font-size: 11px; font-weight: 700; cursor: pointer; transition: all 0.2s; border: 2px solid; }
    .btn:disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
    .btn-accept { background: linear-gradient(180deg, #27ae60 0%, #1e8449 100%); border-color: #2ecc71; color: #fff; }
    .btn-accept:hover:not(:disabled) { transform: scale(1.02); box-shadow: 0 0 10px rgba(46, 204, 113, 0.5); }
    .btn-remove { background: linear-gradient(180deg, #7f8c8d 0%, #5d6d6d 100%); border-color: #95a5a6; color: #fff; }
    .btn-remove:hover:not(:disabled) { background: linear-gradient(180deg, #c0392b 0%, #96281b 100%); border-color: #e74c3c; }
    .btn-fill { background: linear-gradient(180deg, #f39c12 0%, #d68910 100%); border-color: #f1c40f; color: #000; }
    .btn-fill:hover:not(:disabled) { transform: scale(1.02); box-shadow: 0 0 10px rgba(241, 196, 15, 0.5); }

    .notification { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); padding: 12px 24px; border-radius: 10px; font-weight: 700; z-index: 1000; animation: slideIn 0.3s ease; }
    .notification.success { background: #27ae60; color: #fff; }
    .notification.error { background: #e74c3c; color: #fff; }
    @keyframes slideIn { from { opacity: 0; top: 0; } to { opacity: 1; top: 20px; } }

    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
    ::-webkit-scrollbar-thumb { background: #27ae60; border-radius: 4px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="title">CONTRACTS</div>
      <div class="header-stats">
        <div class="stat-box">
          <span class="stat-icon">&#x1F4B0;</span>
          <span class="stat-value" id="gold-display">0</span>
        </div>
        <div class="stat-box">
          <span class="stat-icon">&#x2B50;</span>
          <span class="stat-value">Lv.<span id="level-display">0</span></span>
        </div>
        <button class="close-btn" onclick="closeIframe()">&#x2715;</button>
      </div>
    </div>

    <div class="content">
      <!-- Left Panel: Your Slots -->
      <div class="left-panel">
        <div class="panel-header">
          <div>
            <div class="panel-title">Your Slots</div>
            <div class="panel-subtitle"><span id="slots-unlocked">1</span> / 10 unlocked</div>
          </div>
        </div>
        <div class="slots-list" id="slots-list"></div>
      </div>

      <!-- Right Panel: Available Contracts -->
      <div class="right-panel">
        <div class="panel-header">
          <div class="panel-title">Available</div>
          <div class="refresh-timer">
            <span>&#x1F504;</span>
            <span id="refresh-timer">2:00</span>
          </div>
        </div>
        <div class="available-list" id="available-list"></div>
      </div>
    </div>
  </div>

  <script src="https://portals-labs.github.io/portals-sdk/portals-sdk.js"></script>
  <script>
    // ============================================
    // HUGHBERRY FARMS - CONTRACTS BOARD v2
    // ============================================

    const REFRESH_MS = 2 * 60 * 1000; // 2 minutes
    const FULFILL_MS = 5 * 60 * 1000; // 5 minutes to fulfill
    const COOLDOWN_MS = 5 * 60 * 1000; // 5 minutes cooldown after

    // Items with their properties
    const ITEMS = {
      wheat: { name: 'Wheat', icon: '&#x1F33E;', value: 5, unlockLevel: 0, deductTask: 'Deduct_Crop_Wheat_1' },
      carrot: { name: 'Carrot', icon: '&#x1F955;', value: 10, unlockLevel: 3, deductTask: 'Deduct_Crop_Carrot_1' },
      corn: { name: 'Corn', icon: '&#x1F33D;', value: 8, unlockLevel: 7, deductTask: 'Deduct_Crop_Corn_1' },
      potato: { name: 'Potato', icon: '&#x1F954;', value: 12, unlockLevel: 10, deductTask: 'Deduct_Crop_Potato_1' },
      tomato: { name: 'Tomato', icon: '&#x1F345;', value: 15, unlockLevel: 16, deductTask: 'Deduct_Crop_Tomato_1' },
      pumpkin: { name: 'Pumpkin', icon: '&#x1F383;', value: 30, unlockLevel: 23, deductTask: 'Deduct_Crop_Pumpkin_1' },
      milk: { name: 'Milk', icon: '&#x1F95B;', value: 12, unlockLevel: 2, deductTask: 'Deduct_Milk_1' },
      egg: { name: 'Egg', icon: '&#x1F95A;', value: 8, unlockLevel: 6, deductTask: 'Deduct_Egg_1' },
      wool: { name: 'Wool', icon: '&#x1F9F6;', value: 15, unlockLevel: 13, deductTask: 'Deduct_Wool_1' },
      goat_meat: { name: 'Goat Meat', icon: '&#x1F356;', value: 20, unlockLevel: 18, deductTask: 'Deduct_Goat_Meat_1' },
      honey: { name: 'Honey', icon: '&#x1F36F;', value: 25, unlockLevel: 21, deductTask: 'Deduct_Honey_1' },
      truffle: { name: 'Truffle', icon: '&#x1F344;', value: 50, unlockLevel: 26, deductTask: 'Deduct_Truffle_1' },
      flour: { name: 'Flour', icon: '&#x1F35E;', value: 10, unlockLevel: 4, deductTask: 'Deduct_Flour_1' },
      butter: { name: 'Butter', icon: '&#x1F9C8;', value: 30, unlockLevel: 8, deductTask: 'Deduct_Butter_1' },
      cheese: { name: 'Cheese', icon: '&#x1F9C0;', value: 45, unlockLevel: 9, deductTask: 'Deduct_Cheese_1' },
      bread: { name: 'Bread', icon: '&#x1F956;', value: 35, unlockLevel: 11, deductTask: 'Deduct_Bread_1' },
      blanket: { name: 'Blanket', icon: '&#x1F9E3;', value: 60, unlockLevel: 14, deductTask: 'Deduct_Blanket_1' },
      stew: { name: 'Stew', icon: '&#x1F372;', value: 50, unlockLevel: 15, deductTask: 'Deduct_Stew_1' },
      ragout: { name: 'Ragout', icon: '&#x1F356;', value: 75, unlockLevel: 19, deductTask: 'Deduct_Ragout_1' },
      mead: { name: 'Mead', icon: '&#x1F37A;', value: 100, unlockLevel: 22, deductTask: 'Deduct_Mead_1' },
      pie: { name: 'Pie', icon: '&#x1F967;', value: 100, unlockLevel: 24, deductTask: 'Deduct_Pie_1' },
      meat_pie: { name: 'Meat Pie', icon: '&#x1F969;', value: 90, unlockLevel: 27, deductTask: 'Deduct_Meat_Pie_1' },
      cake: { name: 'Cake', icon: '&#x1F370;', value: 150, unlockLevel: 28, deductTask: 'Deduct_Cake_1' }
    };

    const TIER_CONFIG = {
      1: { minLevel: 0, maxLevel: 9, goldMult: 1.0, xpMult: 1.0 },
      2: { minLevel: 10, maxLevel: 19, goldMult: 1.5, xpMult: 1.5 },
      3: { minLevel: 20, maxLevel: 29, goldMult: 2.0, xpMult: 2.0 },
      4: { minLevel: 30, maxLevel: 39, goldMult: 2.5, xpMult: 2.5 },
      5: { minLevel: 40, maxLevel: 50, goldMult: 3.0, xpMult: 3.0 }
    };

    let gameState = {
      gold: 0,
      level: 0,
      inventory: {},
      talents: { contractor1: 0, contractor2: 0, contractor3: 0 }
    };

    // Available contracts pool
    let availableContracts = [];
    let refreshEndTime = null;

    // Player's 10 slots
    let slots = [];
    for (let i = 0; i < 10; i++) {
      slots.push({
        id: i + 1,
        state: 'empty', // empty, pending, active, cooldown
        contract: null,
        endTime: null // For active (fulfill deadline) or cooldown
      });
    }

    let actionPending = false;
    let notificationTimeout = null;
    let draggedContractIndex = null;

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================

    function getTier(level) {
      if (level >= 40) return 5;
      if (level >= 30) return 4;
      if (level >= 20) return 3;
      if (level >= 10) return 2;
      return 1;
    }

    function getUnlockedSlots() {
      const t = gameState.talents;
      return 1 + t.contractor1 + t.contractor2 + t.contractor3;
    }

    function getAvailableContractCount() {
      return getUnlockedSlots() + 5;
    }

    function getAvailableItems(level) {
      return Object.entries(ITEMS)
        .filter(([key, item]) => item.unlockLevel <= level)
        .map(([key, item]) => ({ key, ...item }));
    }

    function generateContract(level) {
      const tier = getTier(level);
      const tierConfig = TIER_CONFIG[tier];
      const availableItems = getAvailableItems(level);
      if (availableItems.length === 0) return null;

      const numItems = Math.random() < 0.7 ? 1 : 2;
      const selectedItems = [];
      const usedIndices = new Set();

      for (let i = 0; i < numItems && i < availableItems.length; i++) {
        let idx;
        do {
          idx = Math.floor(Math.random() * availableItems.length);
        } while (usedIndices.has(idx) && usedIndices.size < availableItems.length);
        usedIndices.add(idx);

        const item = availableItems[idx];
        const maxQty = Math.max(2, Math.floor(100 / item.value));
        const qty = Math.max(1, Math.floor(Math.random() * maxQty) + 1);
        selectedItems.push({ ...item, qty });
      }

      const baseCost = selectedItems.reduce((sum, item) => sum + item.value * item.qty, 0);
      const profitMult = 1.25 + (Math.random() * 0.5);
      const rawGold = baseCost * profitMult * tierConfig.goldMult;
      const goldReward = Math.max(25, Math.round(rawGold / 25) * 25);
      const xpReward = Math.floor(goldReward * 0.3 * tierConfig.xpMult);

      return { items: selectedItems, goldReward, xpReward, tier };
    }

    function refreshAvailableContracts() {
      var count = getAvailableContractCount();
      availableContracts = [];
      for (var i = 0; i < count; i++) {
        var contract = generateContract(gameState.level);
        if (contract) availableContracts.push(contract);
      }
      refreshEndTime = Date.now() + REFRESH_MS;
      saveState();
      render();
    }

    function formatTime(ms) {
      if (ms <= 0) return '0:00';
      const totalSec = Math.ceil(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      return min + ':' + (sec < 10 ? '0' : '') + sec;
    }

    // ============================================
    // PORTALS COMMUNICATION
    // ============================================

    function triggerTask(taskName) {
      if (typeof PortalsSdk !== 'undefined' && PortalsSdk.sendMessageToUnity) {
        PortalsSdk.sendMessageToUnity(JSON.stringify({ TaskName: taskName, TaskTargetState: 'SetNotActiveToActive' }));
        console.log('[Contracts] Triggered task:', taskName);
      } else {
        console.log('[Contracts] SDK not ready, cannot trigger:', taskName);
      }
    }

    function closeIframe() {
      playSound();
      if (typeof PortalsSdk !== 'undefined' && PortalsSdk.closeIframe) {
        PortalsSdk.closeIframe();
      }
    }

    // ============================================
    // SYNC INVENTORY PARSER (same as index.html)
    // ============================================

    const varMapping = {
      // Root state
      'Gold': { target: 'gold' },
      'Level': { target: 'level' },
      'XP': { target: 'xp' },
      'playerName': { target: '_skip' },
      // Seeds (2-word) - skip
      'Seeds_Wheat': { target: '_skip' }, 'Seeds_Carrot': { target: '_skip' },
      'Seeds_Corn': { target: '_skip' }, 'Seeds_Potato': { target: '_skip' },
      'Seeds_Tomato': { target: '_skip' }, 'Seeds_Pumpkin': { target: '_skip' },
      // Crops (2-word)
      'Crop_Wheat': { target: 'wheat' },
      'Crop_Carrot': { target: 'carrot' },
      'Crop_Corn': { target: 'corn' },
      'Crop_Potato': { target: 'potato' },
      'Crop_Tomato': { target: 'tomato' },
      'Crop_Pumpkin': { target: 'pumpkin' },
      // Animal products (1-word and 2-word)
      'Milk': { target: 'milk' },
      'Egg': { target: 'egg' },
      'Wool': { target: 'wool' },
      'Goat_Meat': { target: 'goat_meat' },
      'Truffle': { target: 'truffle' },
      'Honey': { target: 'honey' },
      // Crafted items (1-word and 2-word)
      'Flour': { target: 'flour' },
      'Bread': { target: 'bread' },
      'Cheese': { target: 'cheese' },
      'Stew': { target: 'stew' },
      'Ragout': { target: 'ragout' },
      'Pie': { target: 'pie' },
      'Meat_Pie': { target: 'meat_pie' },
      'Blanket': { target: 'blanket' },
      'Butter': { target: 'butter' },
      'Cake': { target: 'cake' },
      'Mead': { target: 'mead' },
      // Equipment flags (2-word and 3-word) - skip
      'Has_Beesuit': { target: '_skip' }, 'Has_Basket': { target: '_skip' },
      'Has_Milk_Pail': { target: '_skip' }, 'Has_Shearing_Kit': { target: '_skip' },
      'Has_Butcher_Knife': { target: '_skip' }, 'Has_Truffle_Spade': { target: '_skip' },
      'Has_Starter_Seeds': { target: '_skip' },
      // Recipe flags (3-word and 4-word) - skip
      'Has_Recipe_Flour': { target: '_skip' }, 'Has_Recipe_Bread': { target: '_skip' },
      'Has_Recipe_Cheese': { target: '_skip' }, 'Has_Recipe_Stew': { target: '_skip' },
      'Has_Recipe_Ragout': { target: '_skip' }, 'Has_Recipe_Pie': { target: '_skip' },
      'Has_Recipe_Blanket': { target: '_skip' }, 'Has_Recipe_Butter': { target: '_skip' },
      'Has_Recipe_Cake': { target: '_skip' }, 'Has_Recipe_Mead': { target: '_skip' },
      'Has_Recipe_Meat_Pie': { target: '_skip' },
      // Talent variables (2-word) - skip
      'T_PlotRow2': { target: '_skip' }, 'T_GreenThumb': { target: '_skip' },
      'T_EagerPlanter': { target: '_skip' }, 'T_PlotRow3': { target: '_skip' },
      'T_BountifulHarvest': { target: '_skip' }, 'T_RapidGrowth': { target: '_skip' },
      'T_PlotRow4': { target: '_skip' }, 'T_CropMastery': { target: '_skip' },
      'T_CowHerd': { target: '_skip' }, 'T_ChickenFlock': { target: '_skip' },
      'T_QuickHands': { target: '_skip' }, 'T_SheepPen': { target: '_skip' },
      'T_GoatYard': { target: '_skip' }, 'T_ApiaryExpansion': { target: '_skip' },
      'T_HusbandryKnowledge': { target: '_skip' }, 'T_PigSty': { target: '_skip' },
      'T_AnimalMastery': { target: '_skip' }, 'T_KeenLearner': { target: '_skip' },
      'T_FarmHand': { target: '_skip' }, 'T_Stockman': { target: '_skip' },
      'T_Artisan': { target: '_skip' }, 'T_SeasonedWorker': { target: '_skip' },
      'T_BonusPoint1': { target: '_skip' }, 'T_Prodigy': { target: '_skip' },
      'T_BonusPoint2': { target: '_skip' },
      // Contractor talents (2-word) - these we need
      'T_Contractor1': { target: 't_contractor1' },
      'T_Contractor2': { target: 't_contractor2' },
      'T_Contractor3': { target: 't_contractor3' },
      // Other skips
      'Unspent_Talent_Points': { target: '_skip' },
      'Rebirth_Count': { target: '_skip' },
      'Contract_1_Done': { target: '_skip' }, 'Contract_2_Done': { target: '_skip' },
      'Contract_3_Done': { target: '_skip' }, 'Contract_4_Done': { target: '_skip' },
      'Contract_5_Done': { target: '_skip' }, 'Contract_6_Done': { target: '_skip' },
      'Contract_7_Done': { target: '_skip' }, 'Contract_8_Done': { target: '_skip' },
      'Contract_9_Done': { target: '_skip' }, 'Contract_10_Done': { target: '_skip' }
    };

    function parseSyncInventory(msg) {
      const data = {};
      const parts = msg.replace('Sync_Inventory_', '').split('_');
      let i = 0;

      while (i < parts.length) {
        let matched = false;

        // 4-word keys (Has_Recipe_Meat_Pie)
        if (i + 4 < parts.length) {
          const k4 = parts[i] + '_' + parts[i+1] + '_' + parts[i+2] + '_' + parts[i+3];
          if (varMapping[k4]) {
            if (varMapping[k4].target !== '_skip') {
              const val = parseInt(parts[i+4]);
              data[varMapping[k4].target] = Math.max(0, isNaN(val) ? 0 : val);
            }
            i += 5; matched = true;
          }
        }

        // 3-word keys (Has_Milk_Pail, Unspent_Talent_Points, etc.)
        if (!matched && i + 3 < parts.length) {
          const k3 = parts[i] + '_' + parts[i+1] + '_' + parts[i+2];
          if (varMapping[k3]) {
            if (varMapping[k3].target !== '_skip') {
              const val = parseInt(parts[i+3]);
              data[varMapping[k3].target] = Math.max(0, isNaN(val) ? 0 : val);
            }
            i += 4; matched = true;
          }
        }

        // 2-word keys (Crop_Wheat, Seeds_Wheat, T_Contractor1, etc.)
        if (!matched && i + 2 < parts.length) {
          const k2 = parts[i] + '_' + parts[i+1];
          if (varMapping[k2]) {
            if (varMapping[k2].target !== '_skip') {
              const val = parseInt(parts[i+2]);
              data[varMapping[k2].target] = Math.max(0, isNaN(val) ? 0 : val);
            }
            i += 3; matched = true;
          }
        }

        // 1-word keys (Gold, Milk, Flour, etc.)
        if (!matched && i + 1 < parts.length) {
          const k1 = parts[i];
          if (varMapping[k1]) {
            if (varMapping[k1].target !== '_skip') {
              const val = parseInt(parts[i+1]);
              data[varMapping[k1].target] = Math.max(0, isNaN(val) ? 0 : val);
            }
            i += 2; matched = true;
          }
        }

        if (!matched) i++;
      }

      console.log('[Contracts] Parsed - wheat:', data.wheat, 'milk:', data.milk, 'egg:', data.egg);
      return data;
    }

    function handlePortalsMessage(msg) {
      if (typeof msg !== 'string') return;
      if (msg.indexOf('Sync_Inventory') !== 0) return;

      console.log('[Contracts] Received Sync_Inventory');
      const data = parseSyncInventory(msg);
      console.log('[Contracts] Parsed data:', data);

      gameState.gold = data.gold !== undefined ? data.gold : 0;
      gameState.level = data.level !== undefined ? data.level : 0;

      // Map inventory items - key in ITEMS matches key in data now
      Object.keys(ITEMS).forEach(function(key) {
        var val = data[key] !== undefined ? data[key] : 0;
        gameState.inventory[key] = val;
        if (key === 'milk' || key === 'egg' || key === 'wool') {
          console.log('[Contracts] Mapping inventory:', key, '= data[' + key + '] =', data[key], '→', val);
        }
      });
      console.log('[Contracts] Final inventory.milk:', gameState.inventory.milk, 'inventory.egg:', gameState.inventory.egg);

      gameState.talents.contractor1 = data.t_contractor1 !== undefined ? data.t_contractor1 : 0;
      gameState.talents.contractor2 = data.t_contractor2 !== undefined ? data.t_contractor2 : 0;
      gameState.talents.contractor3 = data.t_contractor3 !== undefined ? data.t_contractor3 : 0;

      console.log('[Contracts] Inventory:', gameState.inventory);

      // Initialize available contracts if not done
      if (availableContracts.length === 0) {
        refreshAvailableContracts();
      }

      actionPending = false;
      render();
    }

    // ============================================
    // DRAG AND DROP
    // ============================================

    function onDragStart(e, index) {
      draggedContractIndex = index;
      // Find the contract-row element (might be a child that was clicked)
      var row = e.target.closest('.contract-row');
      if (row) row.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function onDragEnd(e) {
      draggedContractIndex = null;
      var row = e.target.closest('.contract-row');
      if (row) row.classList.remove('dragging');
    }

    function onSlotDragOver(e, slotIndex) {
      e.preventDefault();
      const slot = slots[slotIndex];
      if (slot.state === 'empty' && slotIndex < getUnlockedSlots()) {
        e.currentTarget.classList.add('drag-over');
      }
    }

    function onSlotDragLeave(e) {
      e.currentTarget.classList.remove('drag-over');
    }

    function onSlotDrop(e, slotIndex) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');

      var slot = slots[slotIndex];
      if (slot.state !== 'empty' || slotIndex >= getUnlockedSlots()) return;
      if (draggedContractIndex === null) return;

      var contract = availableContracts[draggedContractIndex];
      if (!contract) return;

      // Move contract to slot as pending
      slot.state = 'pending';
      slot.contract = contract;

      // Remove from available
      availableContracts.splice(draggedContractIndex, 1);
      draggedContractIndex = null;

      playSound();
      saveState();
      render();
    }

    // ============================================
    // SLOT ACTIONS
    // ============================================

    function acceptContract(slotIndex) {
      var slot = slots[slotIndex];
      if (slot.state !== 'pending') return;

      slot.state = 'active';
      slot.endTime = Date.now() + FULFILL_MS;

      playSound();
      saveState();
      render();
    }

    function removeContract(slotIndex) {
      var slot = slots[slotIndex];
      if (slot.state !== 'pending') return;

      // Return contract to available pool
      if (slot.contract) {
        availableContracts.push(slot.contract);
      }

      slot.state = 'empty';
      slot.contract = null;
      slot.endTime = null;

      playSound();
      saveState();
      render();
    }

    function canFillContract(slot) {
      if (!slot.contract || slot.state !== 'active' || actionPending) {
        console.log('[Contracts] canFillContract FAIL - state:', slot.state, 'actionPending:', actionPending, 'contract:', !!slot.contract);
        return false;
      }
      console.log('[Contracts] Checking contract items:', JSON.stringify(slot.contract.items));
      const result = slot.contract.items.every(item => {
        const owned = gameState.inventory[item.key] || 0;
        console.log('[Contracts] Check item key="' + item.key + '" need:', item.qty, 'have:', owned, 'key in inventory:', item.key in gameState.inventory);
        return owned >= item.qty;
      });
      console.log('[Contracts] canFillContract result:', result);
      return result;
    }

    function fillContract(slotIndex) {
      const slot = slots[slotIndex];
      if (!canFillContract(slot)) return;

      actionPending = true;
      playSound();

      const contract = slot.contract;

      // Optimistically deduct items
      contract.items.forEach(item => {
        gameState.inventory[item.key] = (gameState.inventory[item.key] || 0) - item.qty;
      });

      // Build task list
      const deductTasks = [];
      contract.items.forEach(item => {
        for (let i = 0; i < item.qty; i++) {
          deductTasks.push(item.deductTask);
        }
      });

      const goldTasks = getRewardTasks(contract.goldReward, 'Add_Gold_', [1000, 500, 250, 100, 50, 25]);
      // Only use XP denominations that actually exist as Portals tasks
      const xpTasks = getRewardTasks(contract.xpReward, 'Add_XP_', [500, 250, 100, 50, 25, 10]);

      let delay = 0;
      const STAGGER = 200;

      deductTasks.forEach(function(task) { setTimeout(function() { triggerTask(task); }, delay); delay += STAGGER; });
      goldTasks.forEach(function(task) { setTimeout(function() { triggerTask(task); }, delay); delay += STAGGER; });
      xpTasks.forEach(function(task) { setTimeout(function() { triggerTask(task); }, delay); delay += STAGGER; });

      // Set slot to cooldown
      slot.state = 'cooldown';
      slot.contract = null;
      slot.endTime = Date.now() + COOLDOWN_MS;

      notify('Contract fulfilled! +' + contract.goldReward + 'g +' + contract.xpReward + ' XP', 'success');
      render();
      saveState();

      // Calculate dynamic timeout based on actual task count
      var totalTasks = deductTasks.length + goldTasks.length + xpTasks.length;
      var unlockDelay = (totalTasks * STAGGER) + 500;
      setTimeout(function() { actionPending = false; render(); }, unlockDelay);
    }

    function getRewardTasks(amount, prefix, denominations) {
      const tasks = [];
      let remaining = amount;
      for (const denom of denominations) {
        while (remaining >= denom) {
          tasks.push(prefix + denom);
          remaining -= denom;
        }
      }
      return tasks;
    }

    // ============================================
    // STATE PERSISTENCE
    // ============================================

    function saveState() {
      try {
        var state = {
          slots: slots,
          availableContracts: availableContracts,
          refreshEndTime: refreshEndTime
        };
        localStorage.setItem('hughberry_contracts', JSON.stringify(state));
      } catch (e) {
        // localStorage not available in sandboxed iframe
      }
    }

    function loadState() {
      try {
        var saved = localStorage.getItem('hughberry_contracts');
        if (saved) {
          var state = JSON.parse(saved);
          if (state.slots && Array.isArray(state.slots)) {
            state.slots.forEach(function(savedSlot, i) {
              if (i < slots.length && savedSlot) {
                slots[i].state = savedSlot.state || 'empty';
                slots[i].contract = savedSlot.contract || null;
                slots[i].endTime = savedSlot.endTime || null;
              }
            });
          }
          if (state.availableContracts && Array.isArray(state.availableContracts)) {
            availableContracts = state.availableContracts;
          }
          if (state.refreshEndTime) {
            refreshEndTime = state.refreshEndTime;
          }
        }
      } catch (e) {
        // localStorage not available or parse error
      }
    }

    // ============================================
    // GAME LOOP
    // ============================================

    var gameLoopInterval = null;

    function startGameLoop() {
      if (gameLoopInterval) clearInterval(gameLoopInterval);
      gameLoopInterval = setInterval(gameLoop, 1000);
    }

    function gameLoop() {
      const now = Date.now();

      // Check refresh timer
      if (refreshEndTime && now >= refreshEndTime) {
        refreshAvailableContracts();
      }

      // Check slot timers
      var stateChanged = false;
      slots.forEach(function(slot, i) {
        if (slot.endTime && now >= slot.endTime) {
          if (slot.state === 'active') {
            // Contract expired - no cooldown, just reset to empty
            slot.state = 'empty';
            slot.contract = null;
            slot.endTime = null;
            notify('Contract expired!', 'error');
            stateChanged = true;
          } else if (slot.state === 'cooldown') {
            // Cooldown finished
            slot.state = 'empty';
            slot.contract = null;
            slot.endTime = null;
            stateChanged = true;
          }
        }
      });

      if (stateChanged) {
        saveState();
        render();
      }

      updateTimers();
    }

    function updateTimers() {
      const now = Date.now();

      // Refresh timer
      if (refreshEndTime) {
        document.getElementById('refresh-timer').textContent = formatTime(refreshEndTime - now);
      }

      // Slot timers
      slots.forEach((slot, i) => {
        const timerEl = document.getElementById('slot-timer-' + i);
        if (timerEl && slot.endTime) {
          timerEl.textContent = formatTime(slot.endTime - now);
        }
      });
    }

    // ============================================
    // RENDER
    // ============================================

    function render() {
      document.getElementById('gold-display').textContent = gameState.gold.toLocaleString();
      document.getElementById('level-display').textContent = gameState.level;
      document.getElementById('slots-unlocked').textContent = getUnlockedSlots();

      renderAvailableContracts();
      renderSlots();
    }

    function renderAvailableContracts() {
      var container = document.getElementById('available-list');
      var html = '';

      availableContracts.forEach(function(contract, index) {
        var itemsHtml = '';
        contract.items.forEach(function(item) {
          itemsHtml += '<div class="item"><span class="item-icon">' + item.icon + '</span><span class="item-qty">x' + item.qty + '</span></div>';
        });

        html += '<div class="contract-row" draggable="true" ondragstart="onDragStart(event, ' + index + ')" ondragend="onDragEnd(event)">' +
          '<div class="items">' + itemsHtml + '</div>' +
          '<span class="arrow">→</span>' +
          '<div class="rewards">' +
            '<span class="reward-gold">' + contract.goldReward + 'g</span>' +
            '<span class="reward-xp">' + contract.xpReward + 'xp</span>' +
          '</div>' +
        '</div>';
      });

      if (availableContracts.length === 0) {
        html = '<div style="color:#888;font-size:12px;text-align:center;padding:20px;">No contracts available</div>';
      }

      container.innerHTML = html;
    }

    function renderSlots() {
      var container = document.getElementById('slots-list');
      var unlockedCount = getUnlockedSlots();
      var html = '';

      slots.forEach(function(slot, i) {
        var isUnlocked = i < unlockedCount;
        var slotClass = 'slot' +
          (slot.state === 'pending' || slot.state === 'active' ? ' has-contract' : '') +
          (slot.state === 'active' ? ' active' : '') +
          (slot.state === 'cooldown' ? ' cooldown' : '') +
          (!isUnlocked ? ' locked' : '');

        html += '<div class="' + slotClass + '" ' +
          (isUnlocked && slot.state === 'empty' ? 'ondragover="onSlotDragOver(event, ' + i + ')" ondragleave="onSlotDragLeave(event)" ondrop="onSlotDrop(event, ' + i + ')"' : '') +
          '>';

        // Header with slot number, timer (if active), and status
        html += '<div class="slot-header">';
        html += '<span class="slot-num">Slot ' + (i + 1) + '</span>';
        if (slot.state === 'active' && slot.endTime) {
          html += '<span class="slot-timer-inline" id="slot-timer-' + i + '">' + formatTime(slot.endTime - Date.now()) + '</span>';
        } else if (slot.state === 'cooldown' && slot.endTime) {
          html += '<span class="slot-timer-inline" id="slot-timer-' + i + '" style="color:#888;">' + formatTime(slot.endTime - Date.now()) + '</span>';
        }
        html += '<span class="slot-status status-' + (isUnlocked ? slot.state : 'locked') + '">' +
          (isUnlocked ? slot.state : 'Locked') + '</span>';
        html += '</div>';

        html += '<div class="slot-content">';

        if (!isUnlocked) {
          var req = i < 4 ? 'Contractor I' : (i < 7 ? 'Contractor II' : 'Contractor III');
          html += '<div class="slot-locked-text">&#x1F512;</div>' +
            '<div class="slot-locked-req">Unlock with ' + req + '</div>';
        } else if (slot.state === 'empty') {
          html += '<div class="slot-empty-text">Drag a contract here</div>';
        } else if (slot.state === 'pending' && slot.contract) {
          html += renderSlotContract(slot, i, false);
          html += '<div class="slot-buttons">' +
            '<button class="btn btn-accept" onclick="acceptContract(' + i + ')">Accept</button>' +
            '<button class="btn btn-remove" onclick="removeContract(' + i + ')">Remove</button>' +
          '</div>';
        } else if (slot.state === 'active' && slot.contract) {
          html += renderSlotContract(slot, i, true);
          var canFill = canFillContract(slot);
          html += '<div class="slot-buttons">' +
            '<button class="btn btn-fill" ' + (canFill && !actionPending ? 'onclick="fillContract(' + i + ')"' : 'disabled') + '>Fill Order</button>' +
          '</div>';
        } else if (slot.state === 'cooldown') {
          html += '<div class="slot-empty-text" style="color:#888;">Cooldown...</div>';
        }

        html += '</div></div>';
      });

      container.innerHTML = html;
    }

    function renderSlotContract(slot, slotIndex, showProgress) {
      var html = '<div class="slot-contract">';
      html += '<div class="items">';
      slot.contract.items.forEach(function(item) {
        var owned = gameState.inventory[item.key] || 0;
        var hasEnough = owned >= item.qty;
        html += '<div class="item">' +
          '<span class="item-icon">' + item.icon + '</span>' +
          '<span class="item-qty ' + (showProgress ? (hasEnough ? 'has-enough' : 'not-enough') : '') + '">' +
            (showProgress ? owned + '/' : 'x') + item.qty +
          '</span>' +
        '</div>';
      });
      html += '</div>';
      html += '<div class="rewards">' +
        '<span class="reward-gold">' + slot.contract.goldReward + 'g</span>' +
        '<span class="reward-xp">' + slot.contract.xpReward + ' XP</span>' +
      '</div>';
      html += '</div>';
      return html;
    }

    // ============================================
    // NOTIFICATIONS & SOUND
    // ============================================

    function notify(message, type) {
      if (notificationTimeout) clearTimeout(notificationTimeout);
      const existing = document.querySelector('.notification');
      if (existing) existing.remove();

      const div = document.createElement('div');
      div.className = 'notification ' + type;
      div.textContent = message;
      document.body.appendChild(div);
      notificationTimeout = setTimeout(() => div.remove(), 3000);
    }

    var _clickSound = new Audio('click.mp3');
    _clickSound.preload = 'auto';
    _clickSound.volume = 0.3;
    function playSound() {
      try { _clickSound.currentTime = 0; _clickSound.play().catch(function(){}); } catch(e) {}
    }

    // ============================================
    // INITIALIZATION
    // ============================================

    let lastMessageId = '';
    let lastMessageTime = 0;

    function processMessage(msg, source) {
      const now = Date.now();
      const msgId = msg + '_' + Math.floor(now / 100);
      if (msgId === lastMessageId && now - lastMessageTime < 200) return;
      lastMessageId = msgId;
      lastMessageTime = now;
      handlePortalsMessage(msg);
    }

    function setupMessageListener() {
      if (typeof PortalsSdk !== 'undefined' && PortalsSdk.setMessageListener) {
        PortalsSdk.setMessageListener(function(msg) { processMessage(msg, 'SDK'); });
        console.log('[Contracts] SDK listener registered');
        // Trigger sync now that SDK is ready
        setTimeout(function() { triggerTask('Sync_Inventory'); }, 100);
      } else {
        console.log('[Contracts] Waiting for SDK...');
        setTimeout(setupMessageListener, 100);
      }
    }

    window.addEventListener('message', function(event) {
      if (event.data && typeof event.data === 'string') {
        processMessage(event.data, 'postMessage');
      } else if (event.data && event.data.portalsMessage) {
        processMessage(event.data.portalsMessage, 'postMessage-portals');
      } else if (event.data && event.data.message && typeof event.data.message === 'string') {
        processMessage(event.data.message, 'postMessage-message');
      }
    });

    document.addEventListener('DOMContentLoaded', function() {
      loadState();
      setupMessageListener();
      // Note: Sync_Inventory is triggered in setupMessageListener after SDK ready
      render();
      startGameLoop();
    });

    document.addEventListener('visibilitychange', function() {
      if (!document.hidden) {
        console.log('[Contracts] Visibility restored - restarting game loop');
        startGameLoop();
        triggerTask('Sync_Inventory');
        render();
      }
    });

    window.addEventListener('focus', function() {
      console.log('[Contracts] Window focused - restarting game loop');
      startGameLoop();
      gameLoop();
    });
  </script>
</body>
</html>
